#!/usr/bin/env bash
# meercata: interactive IDS/IPS switcher for Suricata (NFQUEUE)
# - Clear screen on every action & always show banner
# - YAML summary shows ONLY active (uncommented) values from suricata.yaml
# - IPv4/IPv6 IPS-ALL via nftables *or* xtables, with symmetric FORWARD plumbing
# - Fixed: missing backup/restore, OUTPUT allowlist addressing, boot hooks add/remove queues
# - Optional hardening toggles and conditional dependencies
# - NEW: toggle runmode (workers/autofp) + NFQ settings (batchcount, fail-open, queue)

set -eEuo pipefail
IFS=$'\n\t'

# -------- Constants / Defaults (env-overridable) --------
SURICATA_CFG="${SURICATA_CFG:-/etc/suricata/suricata.yaml}"
EDITOR_BIN="${EDITOR:-vim}"
SURICATAMON_BIN="${SURICATAMON_BIN:-/usr/local/bin/suricatamon}"
LOGFILE="${LOGFILE:-/var/log/suricata-mode.log}"
BACKEND="${BACKEND:-auto}"           # auto|xt|nft
QUEUE="${QUEUE:-0}"
XTWAIT="--wait"
ENV_FILE="/etc/default/meercata"

# Interface autodetect (best-effort)
IFACE_DEFAULT="$(ip route 2>/dev/null | awk '/default/ {print $5; exit}')"
IFACE="${IFACE:-${IFACE_DEFAULT:-}}"

# Capability probes
HAVE_IP6=1; command -v ip6tables >/dev/null 2>&1 || HAVE_IP6=0
IPT_BIN="$(command -v iptables || true)"
IPT_V="$(${IPT_BIN:-/bin/false} -V 2>/dev/null || true)"
NFT_BIN="$(command -v nft || true)"

# -------- UI helpers --------
C_RESET=$'\033[0m'; C_OK=$'\033[32m'; C_WARN=$'\033[33m'; C_ERR=$'\033[31m'; C_HEAD=$'\033[34m'; C_BANNER=$'\033[1;36m'
msg()  { printf "%s\n" "$*"; }
ok()   { printf "%b[OK]%b %s\n"   "$C_OK"   "$C_RESET" "$*"; }
warn() { printf "%b[WARN]%b %s\n" "$C_WARN" "$C_RESET" "$*"; }
err()  { printf "%b[ERR]%b %s\n"  "$C_ERR"  "$C_RESET" "$*" >&2; }
logit(){ printf "[%(%F %T)T] %s\n" -1 "$*" >>"$LOGFILE" 2>/dev/null || true; }

banner() {
  printf "%b" "$C_BANNER"
  cat <<'EOF'
  |  \/  |  ___   ___  _ __  ___  __ _ | |_  __ _ 
  | |\/| | / _ \ / _ \| '__|/ __|/ _` || __|/ _` |
  | |  | ||  __/|  __/| |  | (__| (_| || |_| (_| |
  |_|  |_| \___| \___||_|   \___|\__,_| \__|\__,_|
EOF
  printf "%b" "$C_RESET"
}
ui_clear() { clear 2>/dev/null || printf "\033c"; banner; }
ui_pause() { read -rp $'\nPress Enter to continue…' _ || true; }
ui_pause_redraw() { ui_pause; ui_clear; }

need_root() { if [[ ${EUID:-$(id -u)} -ne 0 ]]; then err "Run as root."; exit 1; fi; }
require_bin()  { command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 1; }; }

# Conditional requires depending on backend
require_deps() {
  case "$BACKEND" in
    nft) [[ -n "$NFT_BIN" ]] || { err "Requested nft backend but 'nft' not found"; exit 1; } ;;
    xt)  [[ -n "$IPT_BIN" ]] || { err "Requested xt backend but 'iptables' not found"; exit 1; } ;;
    auto)
      if [[ -n "$NFT_BIN" ]]; then :; elif [[ -n "$IPT_BIN" ]]; then :; else err "Neither 'nft' nor 'iptables' available"; exit 1; fi
      ;;
  esac
}

# Redraw banner on terminal resize & trap errors
trap 'ui_clear' WINCH
trap 'err "Unexpected error on line $LINENO"' ERR

# -------- Suricata checks --------
test_suricata() {
  msg "[*] Testing Suricata config: $SURICATA_CFG"
  suricata -T -c "$SURICATA_CFG" >/dev/null
  ok "Suricata config OK"
}

ensure_fail_open_on()  {
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    sysctl -q net.netfilter.nf_queue_bypass=1 || true
    ok "Fail-open enabled (nf_queue_bypass=1)"; logit "fail-open=1"
  else warn "Fail-open sysctl not available on this kernel."; fi
}
ensure_fail_open_off() {
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    sysctl -q net.netfilter.nf_queue_bypass=0 || true
    ok "Fail-open disabled (nf_queue_bypass=0)"; logit "fail-open=0"
  fi
}

# -------- iptables helpers (xtables) --------
ipt_del_v4() { ${IPT_BIN:-iptables} $XTWAIT -D "$@" 2>/dev/null || true; }
ipt_del_v6() { [[ $HAVE_IP6 -eq 1 ]] && ip6tables $XTWAIT -D "$@" 2>/dev/null || true; }
ipt_ins_v4() { ${IPT_BIN:-iptables} $XTWAIT -I "$@"; }
ipt_ins_v6() { [[ $HAVE_IP6 -eq 1 ]] && ip6tables $XTWAIT -I "$@"; }

flush_nfq_xt() {
  msg "[*] Flushing NFQUEUE hooks (xtables)…"
  # v4
  ipt_del_v4 INPUT   -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v4 OUTPUT  -j NFQUEUE --queue-num "$QUEUE"
  # symmetric FORWARD (both directions)
  ipt_del_v4 FORWARD -i "${IFACE:-}" -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v4 FORWARD -o "${IFACE:-}" -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v4 INPUT  -i lo -j ACCEPT
  ipt_del_v4 OUTPUT -o lo -j ACCEPT
  ipt_del_v4 INPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_del_v4 OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  # v6
  ipt_del_v6 INPUT   -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 OUTPUT  -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 FORWARD -i "${IFACE:-}" -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 FORWARD -o "${IFACE:-}" -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 INPUT  -i lo -j ACCEPT
  ipt_del_v6 OUTPUT -o lo -j ACCEPT
  ipt_del_v6 INPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_del_v6 OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ok "NFQUEUE hooks removed (xtables)"; logit "NFQUEUE flushed (xt) queue=$QUEUE"
}

# Conntrack fast-path (must be inserted BEFORE NFQUEUE)
add_ct_fastpath_xt() {
  ipt_ins_v4 INPUT  1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_ins_v4 OUTPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_ins_v6 INPUT  1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_ins_v6 OUTPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
}

# Loopback accepts (must be before NFQUEUE)
insert_lo_accepts_xt() {
  ipt_ins_v4 INPUT  1 -i lo -j ACCEPT
  ipt_ins_v4 OUTPUT 1 -o lo -j ACCEPT
  ipt_ins_v6 INPUT  1 -i lo -j ACCEPT
  ipt_ins_v6 OUTPUT 1 -o lo -j ACCEPT
}

# Queue all (position 2 so it's after fast-path/loopback)
queue_all_xt() {
  local ifc="${IFACE:-}"
  if [[ -n "$ifc" ]]; then
    ipt_ins_v4 INPUT   2 -i "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 OUTPUT  2 -o "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    # symmetric FORWARD
    ipt_ins_v4 FORWARD 2 -i "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 FORWARD 2 -o "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 INPUT   2 -i "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 OUTPUT  2 -o "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 FORWARD 2 -i "$ifc" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 FORWARD 2 -o "$ifc" -j NFQUEUE --queue-num "$QUEUE"
  else
    ipt_ins_v4 INPUT   2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 OUTPUT  2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 FORWARD 2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 INPUT   2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 OUTPUT  2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 FORWARD 2 -j NFQUEUE --queue-num "$QUEUE"
  fi
}

allowlist_insert() {
  read -rp "Direction (in/out/forward) [in]: " dir; dir="${dir:-in}"
  read -rp "Protocol (tcp/udp/all) [all]: " proto; proto="${proto:-all}"
  read -rp "Address (IP/CIDR) to allow (e.g., 1.2.3.4 or 10.0.0.0/24): " addr
  read -rp "Port (blank for any): " port || true

  local chain flagproto=() flagport=() flagaddr=()
  case "$dir" in
    in)      chain=INPUT;  [[ -n "$addr" ]] && flagaddr=( -s "$addr" ) ;;
    out)     chain=OUTPUT; [[ -n "$addr" ]] && flagaddr=( -d "$addr" ) ;;
    forward) chain=FORWARD; [[ -n "$addr" ]] && flagaddr=( -s "$addr" ) ;;
    *) err "Invalid direction"; return ;;
  esac
  [[ "$proto" != all ]] && flagproto=( -p "$proto" )
  [[ -n "${port:-}" ]] && flagport=( --dport "$port" )

  ${IPT_BIN:-iptables} $XTWAIT -I "$chain" 1 "${flagproto[@]}" "${flagaddr[@]}" "${flagport[@]}" -j ACCEPT
  ok "IPv4 allowlisted at top of $chain"; logit "allowlist v4 $chain proto=$proto addr=$addr port=${port:-any}"

  if [[ $HAVE_IP6 -eq 1 ]]; then
    ip6tables $XTWAIT -I "$chain" 1 "${flagproto[@]}" "${flagaddr[@]}" "${flagport[@]}" -j ACCEPT || true
    ok "IPv6 allowlisted at top of $chain"; logit "allowlist v6 $chain proto=$proto addr=$addr port=${port:-any}"
  fi
}

# -------- nftables helpers --------
nft_flush() {
  if [[ -n "$NFT_BIN" ]] && $NFT_BIN list table inet suri >/dev/null 2>&1; then
    $NFT_BIN delete table inet suri || true
    ok "nftables: removed table inet suri"
  else
    warn "nftables: table inet suri not present"
  fi
}

nft_install_queue_all() {
  [[ -n "$NFT_BIN" ]] || { err "nft not found"; return 1; }
  local ifc="${IFACE:-}" match_in="" match_out=""
  [[ -n "$ifc" ]] && match_in="iifname \"$ifc\"" && match_out="oifname \"$ifc\""
  if $NFT_BIN list table inet suri >/dev/null 2>&1; then $NFT_BIN delete table inet suri; fi
  $NFT_BIN -f - <<EOF
create table inet suri
add chain inet suri preraw { type filter hook prerouting priority raw; policy accept; }
add chain inet suri outraw { type filter hook output     priority raw; policy accept; }
add rule inet suri preraw ct state established,related accept
add rule inet suri outraw ct state established,related accept
add rule inet suri preraw meta l4proto { tcp, udp, icmp, ipv6-icmp } $match_in queue flags bypass to $QUEUE
add rule inet suri outraw meta l4proto { tcp, udp, icmp, ipv6-icmp } $match_out queue flags bypass to $QUEUE
EOF
  ok "nftables: inet/suri installed (queue ${QUEUE}; iface=${IFACE:-any})"
}

nft_install_queue_minimal() {
  [[ -n "$NFT_BIN" ]] || { err "nft not found"; return 1; }
  local ifc="${IFACE:-}" match_in="" match_out=""
  [[ -n "$ifc" ]] && match_in="iifname \"$ifc\"" && match_out="oifname \"$ifc\""
  if $NFT_BIN list table inet suri >/dev/null 2>&1; then $NFT_BIN delete table inet suri; fi
  $NFT_BIN -f - <<EOF
create table inet suri
add chain inet suri preraw { type filter hook prerouting priority raw; policy accept; }
add chain inet suri outraw { type filter hook output     priority raw; policy accept; }
add rule inet suri preraw ct state established,related accept
add rule inet suri outraw ct state established,related accept
add rule inet suri preraw tcp dport 7070 $match_in queue flags bypass to $QUEUE
add rule inet suri outraw tcp sport 7070 $match_out queue flags bypass to $QUEUE
add rule inet suri preraw meta l4proto { icmp, ipv6-icmp } $match_in queue flags bypass to $QUEUE
add rule inet suri outraw meta l4proto { icmp, ipv6-icmp } $match_out queue flags bypass to $QUEUE
EOF
  ok "nftables: inet/suri minimal (TCP:7070 + ICMP/ICMPv6; iface=${IFACE:-any})"
}

nft_status() {
  if [[ -n "$NFT_BIN" ]]; then
    echo "===== nftables (inet suri) ====="
    $NFT_BIN list table inet suri 2>/dev/null || echo "(no inet suri table)"
  fi
}

# -------- iptables ruleset backup/restore --------
backup_rules() {
  local dir=/var/backups/meercata; mkdir -p "$dir"
  ${IPT_BIN:-iptables}-save >"$dir/iptables.v4" || true
  if [[ $HAVE_IP6 -eq 1 ]]; then ip6tables-save >"$dir/iptables.v6" || true; fi
  ok "Saved xtables rules to $dir/iptables.v4 and .v6"; logit "backup xtables -> $dir"
}
restore_rules() {
  local dir=/var/backups/meercata
  if [[ -f "$dir/iptables.v4" ]]; then ${IPT_BIN:-iptables}-restore <"$dir/iptables.v4"; ok "Restored IPv4 rules"; else warn "No IPv4 backup at $dir/iptables.v4"; fi
  if [[ $HAVE_IP6 -eq 1 && -f "$dir/iptables.v6" ]]; then ip6tables-restore <"$dir/iptables.v6"; ok "Restored IPv6 rules"; else warn "No IPv6 backup at $dir/iptables.v6"; fi
}

# -------- Suricata process control --------
suricata_stop() { systemctl stop suricata 2>/dev/null || true; pkill -x suricata 2>/dev/null || true; }

suricata_ids() {
  [[ -n "${IFACE:-}" ]] || choose_iface
  ui_clear
  printf "%b=========================%b\n" "$C_HEAD" "$C_RESET"
  printf "%b SURICATA: IDS MODE %b\n" "$C_HEAD" "$C_RESET"
  printf "%b (sniff-only) %b\n" "$C_HEAD" "$C_RESET"
  printf "%b=========================%b\n" "$C_HEAD" "$C_RESET"
  suricata_stop; flush_nfq_xt; nft_flush; test_suricata
  logit "MODE=IDS iface=$IFACE"
  exec suricata -c "$SURICATA_CFG" -i "$IFACE"
}

_install_queue_backend() {
  case "$BACKEND" in
    nft) nft_install_queue_all ;;
    xt)  add_ct_fastpath_xt; insert_lo_accepts_xt; queue_all_xt ;;
    auto)
      if [[ -n "$NFT_BIN" ]]; then nft_install_queue_all; else add_ct_fastpath_xt; insert_lo_accepts_xt; queue_all_xt; fi
      ;;
  esac
}

_flush_queue_backend() {
  case "$BACKEND" in
    nft) nft_flush ;;
    xt)  flush_nfq_xt ;;
    auto)
      if [[ -n "$NFT_BIN" ]] ; then nft_flush; else flush_nfq_xt; fi
      ;;
  esac
}

# force best runmode for NFQ IPS
_set_runmode_workers_once() {
  awk '/^[ \t]*runmode:[ \t]*/{print $2; exit}' "$SURICATA_CFG" 2>/dev/null | grep -q '^workers$' || {
    _yaml_set_runmode "workers"
  }
}

suricata_ips_all() {
  [[ -n "${IFACE:-}" ]] || choose_iface
  ui_clear
  printf "%b============================%b\n" "$C_ERR" "$C_RESET"
  printf "%b SURICATA: IPS-ALL MODE %b\n" "$C_ERR" "$C_RESET"
  printf "%b (inline enforce via NFQUEUE)%b\n" "$C_ERR" "$C_RESET"
  printf "%b============================%b\n" "$C_ERR" "$C_RESET"

  require_deps
  _set_runmode_workers_once            # ensure workers for nfq.batchcount validity
  suricata_stop; flush_nfq_xt; nft_flush; test_suricata; ensure_fail_open_on
  _install_queue_backend

  local used_backend="auto"; [[ -n "$NFT_BIN" ]] && used_backend="nft"; [[ "$BACKEND" == xt ]] && used_backend="xt"
  ok "Using backend: $used_backend"
  logit "MODE=IPS-ALL iface=$IFACE queue=$QUEUE backend=${used_backend}"
  exec suricata -c "$SURICATA_CFG" -q "$QUEUE"
}

# -------- Rules: YAML parsing (mawk-safe) --------
_yaml_default_rule_path() {
  awk -F': *' '
    /^[ \t]*#/ {next}
    /^[ \t]*default-rule-path:[ \t]*/ { gsub(/["'\'']/, "", $2); print $2; exit }
  ' "$SURICATA_CFG"
}

_yaml_rulefiles() {
  awk '
    BEGIN { INBLK=0 }
    /^[ \t]*rule-files:[ \t]*$/ && $0 !~ /^[ \t]*#/ { INBLK=1; next }
    INBLK && /^[^ \t#][^:]*:/ { INBLK=0 }
    INBLK {
      line=$0
      if (line ~ /^[ \t]*#[ \t]*-[ \t]*/) {
        sub(/^[ \t]*#[ \t]*/, "", line)
        sub(/[ \t]+#.*/, "", line)
        gsub(/["'\'']/, "", line)
        if (line != "") print "disabled\t" line
        next
      }
      if (line ~ /^[ \t]*-[ \t]*/) {
        sub(/^[ \t]*-[ \t]*/, "", line)
        sub(/[ \t]+#.*/, "", line)
        gsub(/["'\'']/, "", line)
        if (line != "") print "enabled\t" line
        next
      }
    }
  ' "$SURICATA_CFG"
}

_resolve_rule_path() {
  local base="$1" file="$2"
  if [[ "$file" = /* ]]; then printf "%s\n" "$file"; else printf "%s/%s\n" "${base%/}" "$file"; fi
}

# -------- Rules: enable/disable (idempotent) --------
_backup_yaml() {
  local ts dst
  ts="$(date +%Y%m%d-%H%M%S)"; dst="${SURICATA_CFG}.${ts}.bak"
  cp -a -- "$SURICATA_CFG" "$dst"
  ok "Backup: $dst"
}

_set_rulefile_state() {
  local target="$1" desired="$2"
  [[ -n "$target" && -n "$desired" ]] || { err "Missing args"; return 1; }
  local tmp; tmp="$(mktemp)"
  awk -v target="$target" -v desired="$desired" '
    BEGIN { INBLK=0; changed=0 }
    /^[ \t]*rule-files:[ \t]*$/ && $0 !~ /^[ \t]*#/ { INBLK=1; print; next }
    INBLK && /^[^ \t#].*:/ { INBLK=0 }
    INBLK {
      raw=$0; indent = match(raw,/[^ \t]/) - 1; if (indent < 0) indent=0; spaces = substr("                ",1,indent)
      line=raw; gsub(/["'\'']/, "", line); l=line
      sub(/^[ \t]*#?[ \t]*/, "", l); sub(/^[ \t]*-[ \t]*/, "", l); sub(/[ \t]+#.*/, "", l)
      if (l == target) {
        if (desired == "enabled") { sub(/^[ \t]*#[ \t]*/, "", raw); if (raw !~ /^[ \t]*-[ \t]*/) raw = spaces "- " target; print raw }
        else { if (raw !~ /^[ \t]*#/) raw = spaces "# - " target; else sub(/^[ \t]*#[ \t]*/, spaces "# - "); print raw }
        changed=1; next
      }
    }
    { print }
    END { if (!changed) exit 2 }
  ' "$SURICATA_CFG" > "$tmp" && mv "$tmp" "$SURICATA_CFG" || { rm -f "$tmp"; return 1; }
}

_rules_insight() {
  test_suricata 2>/dev/null || true
  local base; base="$( _yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"
  msg "----- rule-files ($SURICATA_CFG; default-path: $base) -----"

  local enabled=() disabled=() all=()
  local state file path size lines
  while IFS=$'\t' read -r state file; do
    [[ -z "${file:-}" ]] && continue
    all+=("$state|$file"); if [[ "$state" == enabled ]]; then enabled+=("$file"); else disabled+=("$file"); fi
  done < <(_yaml_rulefiles | sort -u)

  if ((${#all[@]}==0)); then warn "No rule-files found in YAML."; return; fi

  msg ""; msg "Enabled:"
  for file in "${enabled[@]}"; do
    path="$( _resolve_rule_path "$base" "$file")"
    if [[ -f "$path" ]]; then size="$(du -h "$path" | awk '{print $1}')"; lines="$(wc -l <"$path" 2>/dev/null || echo 0)"
      printf " - %-24s -> %s (exists, %s, %s lines)\n" "$file" "$path" "$size" "$lines"
    else printf " - %-24s -> %s (missing)\n" "$file" "$path"; fi
  done

  msg ""; msg "Disabled:"
  if ((${#disabled[@]}==0)); then msg " (none)"; else
    for file in "${disabled[@]}"; do
      path="$( _resolve_rule_path "$base" "$file")"
      if [[ -f "$path" ]]; then size="$(du -h "$path" | awk '{print $1}')"; lines="$(wc -l <"$path" 2>/dev/null || echo 0)"
        printf " - %-24s -> %s (exists, %s, %s lines)\n" "$file" "$path" "$size" "$lines"
      else printf " - %-24s -> %s (missing)\n" "$file" "$path"; fi
    done
  fi
  msg ""; msg "Summary: ${#enabled[@]} enabled, ${#disabled[@]} disabled, total ${#all[@]}."
}

_has_dialog()   { command -v dialog >/dev/null 2>&1; }
_has_whiptail() { command -v whiptail >/dev/null 2>&1; }

_rulefiles_collect() {
  mapfile -t ITEMS  < <( _yaml_rulefiles | awk -F'\t' '{print $2}' | sed 's/^[ \t]*//; s/[ \t]*$//' | awk 'length>0' | sort -u )
  mapfile -t STATES < <( _yaml_rulefiles | awk -F'\t' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); if (length($2)>0) print $1 "\t" $2}' | sort -u )
}

_checklist_enable_disable() {
  _rulefiles_collect; ((${#ITEMS[@]})) || { err "No rule-files in YAML."; return 1; }
  declare -A cur; local s state f
  for s in "${STATES[@]}"; do state="${s%%$'\t'*}"; f="${s#*$'\t'}"; [[ -z "$f" ]] && continue; cur["$f"]="$state"; done
  CHOSEN=()
  if _has_dialog; then
    local args=() out st desc
    for f in "${ITEMS[@]}"; do [[ -z "$f" ]] && continue; st="${cur[$f]:-disabled}"; desc="Rule-file: $f"; args+=("$f" "$desc" "$([[ "$st" == enabled ]] && echo on || echo off)"); done
    if out=$(dialog --stdout --no-tags --checklist "Select rule-files to ENABLE (unchecked will be DISABLED)" 20 80 14 "${args[@]}"); then read -r -a CHOSEN <<<"$out"; else return 1; fi
  elif _has_whiptail; then
    local args=() out st desc
    for f in "${ITEMS[@]}"; do [[ -z "$f" ]] && continue; st="${cur[$f]:-disabled}"; desc="Rule-file: $f"; args+=("$f" "$desc" "$([[ "$st" == enabled ]] && echo ON || echo OFF)"); done
    if out=$(whiptail --title "Suricata rule-files" --separate-output --checklist "Select rule-files to ENABLE (unchecked will be DISABLED)" 20 80 14 "${args[@]}" 3>&1 1>&2 2>&3); then mapfile -t CHOSEN <<<"$out"; else return 1; fi
  else
    msg "Available rule-files (current enabled marked [x]):"; local i=1
    for f in "${ITEMS[@]}"; do printf " %2d) [%s] %s\n" "$i" "$([[ ${cur[$f]:-disabled} == enabled ]] && echo x || echo ' ')" "$f"; ((i++)); done
    read -rp "Enter indexes to ENABLE (others DISABLED), e.g. '1 3' or '1,3': " line || true; [[ -z "${line:-}" ]] && return 1
    line="${line//,/ }"; local picks=( $line ) idx
    for idx in "${picks[@]}"; do [[ "$idx" =~ ^[0-9]+$ ]] || continue; (( idx>=1 && idx<=${#ITEMS[@]} )) || continue; f="${ITEMS[$((idx-1))]}"; [[ -z "$f" ]] && continue; CHOSEN+=("$f"); done
  fi
  declare -A WANT; for f in "${ITEMS[@]}"; do [[ -z "$f" ]] && continue; WANT["$f"]=disabled; done
  for f in "${CHOSEN[@]:-}"; do [[ -z "$f" ]] && continue; WANT["$f"]=enabled; done
  _backup_yaml; local changed=0
  for f in "${ITEMS[@]}"; do [[ -z "$f" ]] && continue; if [[ "${WANT[$f]}" != "${cur[$f]:-disabled}" ]]; then if _set_rulefile_state "$f" "${WANT[$f]}"; then printf "[OK] %s → %s\n" "$f" "${WANT[$f]}"; changed=1; else printf "[ERR] %s → %s (failed)\n" "$f" "${WANT[$f]}"; fi; fi; done
  (( changed )) && ok "Applied rule-file changes." || ok "No changes needed."
}

_open_rulefiles_vim() {
  mapfile -t ITEMS < <( _yaml_rulefiles | awk -F'\t' '{print $2}' | sed 's/^[ \t]*//; s/[ \t]*$//' | awk 'length>0' | sort -u )
  ((${#ITEMS[@]})) || { err "No rule-files in YAML."; return 1; }
  local base; base="$( _yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"
  msg "Available rule-files:"; local i=1 f
  for f in "${ITEMS[@]}"; do printf " %2d) %s\n" "$i" "$f"; ((i++)); done
  read -rp "Pick index(es) to OPEN in ${EDITOR_BIN} (e.g., '1 3' or '1,3'): " line || true; [[ -z "${line:-}" ]] && return 0
  line="${line//,/ }"; local picks=( $line ) idx path paths=()
  for idx in "${picks[@]}"; do [[ "$idx" =~ ^[0-9]+$ ]] || continue; (( idx>=1 && idx<=${#ITEMS[@]} )) || continue; f="${ITEMS[$((idx-1))]}"; [[ -z "$f" ]] && continue; path="$( _resolve_rule_path "$base" "$f")"
    if [[ ! -f "$path" ]]; then warn "Missing: $path — create?"; read -rp "[y/N]: " yn || true; if [[ "${yn,,}" == y ]]; then mkdir -p -- "$(dirname "$path")"; : > "$path"; fi; fi
    paths+=("$path"); done
  ((${#paths[@]})) && "$EDITOR_BIN" "${paths[@]}"
}

# -------- YAML Config Summary (ONLY active settings) --------
yaml_config_summary() {
  ui_clear
  echo "===== SURICATA YAML SUMMARY ====="; echo "YAML file: $SURICATA_CFG"
  local base; base="$( _yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"; echo "default-rule-path: $base"
  awk '
    /^[ \t]*#/ { next }
    /^[ \t]*vars:[ \t]*$/ { invars=1; next }
    invars==1 && /^[ \t]*address-groups:[ \t]*$/ { inaddr=1; next }
    inaddr==1 && /^[ \t]*HOME_NET:[ \t]*/ { s=$0; sub(/^[ \t]*HOME_NET:[ \t]*/, "", s); gsub(/["""'"'"']/, "", s); print "  HOME_NET: " s }
    inaddr==1 && /^[ \t]*EXTERNAL_NET:[ \t]*/ { s=$0; sub(/^[ \t]*EXTERNAL_NET:[ \t]*/, "", s); gsub(/["""'"'"']/, "", s); print "  EXTERNAL_NET: " s }
    inaddr==1 && /^[ \t]*[^ #].*:/ && $0 !~ /HOME_NET:|EXTERNAL_NET:/ { if ($1!~/-/) inaddr=0 }
  ' "$SURICATA_CFG"
  awk '
    BEGIN{inblk=0; printed=0}
    /^[ \t]*#/ { next }
    /^[ \t]*af-packet:[ \t]*$/ { if (printed==0) { print "capture:"; printed=1 } ; print "  af-packet:"; inblk=1; next }
    inblk==1 && /^[^ \t#].*:/ { inblk=0 }
    inblk==1 && /^[ \t]*-[ \t]*interface:[ \t]*/ { s=$0; sub(/^[ \t]*-[ \t]*interface:[ \t]*/, "", s); gsub(/["""'"'"']/, "", s); print "    - " s }
  ' "$SURICATA_CFG"
  awk '
    BEGIN{inblk=0; seen=0}
    /^[ \t]*#/ { next }
    /^[ \t]*pcap:[ \t]*$/ { print "  pcap:"; inblk=1; seen=1; next }
    inblk==1 && /^[^ \t#].*:/ { inblk=0 }
    inblk==1 && /^[ \t]*interface:[ \t]*/ { s=$0; sub(/^[ \t]*interface:[ \t]*/, "", s); gsub(/["""'"'"']/, "", s); print "    - " s }
  ' "$SURICATA_CFG"
  awk '
    BEGIN{inblk=0; any=0}
    /^[ \t]*#/ { next }
    /^[ \t]*nfq:[ \t]*$/ { inblk=1; print "  nfq:"; next }
    inblk==1 && /^[^ \t#].*:/ { inblk=0 }
    inblk==1 {
      if ($0 ~ /^[ \t]*mode:[ \t]*/)      { s=$0; sub(/^[ \t]*mode:[ \t]*/, "", s); print "    mode: " s; any=1 }
      if ($0 ~ /^[ \t]*inline:[ \t]*/)    { s=$0; sub(/^[ \t]*inline:[ \t]*/, "", s); print "    inline: " s; any=1 }
      if ($0 ~ /^[ \t]*queue:[ \t]*/)     { s=$0; sub(/^[ \t]*queue:[ \t]*/, "", s); print "    queue: " s; any=1 }
      if ($0 ~ /^[ \t]*fail-open:[ \t]*/) { s=$0; sub(/^[ \t]*fail-open:[ \t]*/, "", s); print "    fail-open: " s; any=1 }
    }
  ' "$SURICATA_CFG"
  ui_pause_redraw
}

# -------- YAML mutation helpers (runmode + nfq) --------
_yaml_set_runmode() {
  local mode="$1" tmp; tmp="$(mktemp)"
  [[ "$mode" == "workers" || "$mode" == "autofp" ]] || { err "runmode must be workers|autofp"; return 1; }
  awk -v mode="$mode" '
    BEGIN{done=0}
    {
      if ($0 ~ /^[ \t]*#?[ \t]*runmode:[ \t]*/) {
        sub(/^[ \t]*#?[ \t]*/, "", $0);
        sub(/runmode:[ \t]*.*/, "runmode: " mode);
        print; done=1; next
      }
      print
    }
    END{
      if (!done) printf("runmode: %s\n", mode)
    }
  ' "$SURICATA_CFG" >"$tmp" && mv "$tmp" "$SURICATA_CFG"
  ok "Set runmode: $mode"
}

_yaml_nfq_set_kv() {
  local key="$1" val="$2" tmp; tmp="$(mktemp)"
  awk -v key="$key" -v val="$val" '
    BEGIN{inblk=0; haveblk=0; set=0}
    /^[ \t]*#/ { print; next }
    /^[ \t]*nfq:[ \t]*$/ { print "nfq:"; inblk=1; haveblk=1; next }
    inblk==1 && /^[^ \t#].*:/ { if (!set) printf("  %s: %s\n", key, val); inblk=0 }
    {
      if (inblk==1) {
        line=$0
        if (line ~ /^[ \t]*#?[ \t]*([A-Za-z0-9_-]+):[ \t]*/) {
          k=$0; sub(/^[ \t]*#?[ \t]*/, "", k);
          match(k,/^[A-Za-z0-9_-]+/)
          kk=substr(k,RSTART,RLENGTH)
          if (kk==key) { printf("  %s: %s\n", key, val); set=1; next }
        }
        print; next
      } else {
        print
      }
    }
    END{
      if (!haveblk) {
        print "nfq:"
        printf("  %s: %s\n", key, val)
      } else if (inblk==1 && !set) {
        printf("  %s: %s\n", key, val)
      }
    }
  ' "$SURICATA_CFG" >"$tmp" && mv "$tmp" "$SURICATA_CFG"
  ok "Set nfq.${key}: ${val}"
}

yaml_runmode_toggle() {
  local cur
  cur="$(awk '/^[ \t]*runmode:[ \t]*/{print $2; exit}' "$SURICATA_CFG" 2>/dev/null || true)"
  [[ -z "$cur" ]] && cur="autofp"
  local next="workers"; [[ "$cur" == "workers" ]] && next="autofp"
  _yaml_set_runmode "$next"
}

yaml_set_nfq_batchcount() {
  read -rp "nfq.batchcount (number, empty to remove): " bc || true
  if [[ -z "${bc:-}" ]]; then
    local tmp; tmp="$(mktemp)"
    awk '
      BEGIN{inblk=0}
      /^[ \t]*nfq:[ \t]*$/ {print; inblk=1; next}
      inblk==1 && /^[^ \t#].*:/ {inblk=0}
      { if (!(inblk==1 && $0 ~ /^[ \t]*batchcount:/)) print }
    ' "$SURICATA_CFG" >"$tmp" && mv "$tmp" "$SURICATA_CFG"
    ok "Removed nfq.batchcount"
  else
    [[ "$bc" =~ ^[0-9]+$ ]] || { err "batchcount must be integer"; return 1; }
    _yaml_nfq_set_kv "batchcount" "$bc"
  fi
}

yaml_set_nfq_failopen() {
  read -rp "nfq.fail-open (yes/no) [yes]: " ans || true
  ans="${ans:-yes}"; case "${ans,,}" in
    y|yes) _yaml_nfq_set_kv "fail-open" "yes" ;;
    n|no)  _yaml_nfq_set_kv "fail-open" "no"  ;;
    *) err "Enter yes or no"; return 1 ;;
  esac
}

yaml_set_nfq_queue_to_env() {
  _yaml_nfq_set_kv "queue" "$QUEUE"
  ok "Aligned YAML nfq.queue to QUEUE=${QUEUE}"
}

# -------- Status / Diagnostics --------
status_show() {
  ui_clear
  echo "===== SURICATA STATUS ====="
  if systemctl is-active --quiet suricata 2>/dev/null; then ok "systemd suricata: active"; else warn "systemd suricata: inactive"; fi
  pgrep -ax suricata || warn "No suricata process found"
  echo; echo "===== NFQUEUE (IPv4) ====="; ${IPT_BIN:-iptables} -S 2>/dev/null | grep -n NFQUEUE || echo "(none or iptables missing)"
  if [[ $HAVE_IP6 -eq 1 ]]; then echo; echo "===== NFQUEUE (IPv6) ====="; ip6tables -S 2>/dev/null | grep -n NFQUEUE || echo "(none or ip6tables missing)"; fi
  echo; nft_status
  echo; echo "===== ENV ====="
  echo "IFACE=$IFACE QUEUE=$QUEUE CFG=$SURICATA_CFG"
  if [[ -n "$IPT_V" ]]; then echo "iptables backend: $IPT_V"; [[ "$IPT_V" == *nf_tables* ]] && warn "iptables-nft backend detected."; fi
  case "$BACKEND" in auto) echo "backend preference: auto (prefer nft if present, else xtables)";; xt) echo "backend preference: xtables";; nft) echo "backend preference: nftables";; esac
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then echo "fail-open: $(sysctl -n net.netfilter.nf_queue_bypass 2>/dev/null)"; else echo "fail-open: (not supported)"; fi
  ui_pause_redraw
}

show_counters() { ui_clear; ${IPT_BIN:-iptables} -vnL || true; if [[ $HAVE_IP6 -eq 1 ]]; then echo; ip6tables -vnL || true; fi; ui_pause_redraw; }

# -------- Live monitor --------
live_monitor() {
  ui_clear
  local log="${SURICATA_EVE:-/var/log/suricata/eve.json}"
  if [[ -x "$SURICATAMON_BIN" ]]; then
    ok "Launching suricatamon (Ctrl-C to exit)…"
    SURICATAMON_SHOW_SID="${SURICATAMON_SHOW_SID:-1}" \
    SURICATAMON_WIDE="${SURICATAMON_WIDE:-1}" \
    "$SURICATAMON_BIN" || warn "suricatamon exited with a non-zero status."
  else
    warn "suricatamon not found at: $SURICATAMON_BIN"; warn "Install it and/or set SURICATAMON_BIN to its path."
    [[ -r "$log" ]] || { err "Cannot read $log"; ui_pause_redraw; return 1; }
    msg "[*] Fallback: tailing $log (first 200 lines)…"; tail -n 200 "$log"
  fi
  ui_pause_redraw
}

# -------- Boot integration (systemd) --------
install_boot_ips_all() {
  require_deps
  mkdir -p "$(dirname "$ENV_FILE")"
  cat > "$ENV_FILE" <<EOF
IFACE=${IFACE}
QUEUE=${QUEUE}
BACKEND=${BACKEND}
SURICATA_CFG=${SURICATA_CFG}
EOF
  local unit=/etc/systemd/system/suricata-inline.service
  cat > "$unit" <<'EOF'
[Unit]
Description=Suricata Inline (NFQUEUE) with pre-hook install
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
EnvironmentFile=/etc/default/meercata
ExecStartPre=/usr/bin/env bash -c 'set -e; case "${BACKEND:-auto}" in nft) if nft list table inet suri >/dev/null 2>&1; then nft delete table inet suri; fi; nft -f - <<NF
create table inet suri
add chain inet suri preraw { type filter hook prerouting priority raw; policy accept; }
add chain inet suri outraw { type filter hook output     priority raw; policy accept; }
add rule inet suri preraw ct state established,related accept
add rule inet suri outraw ct state established,related accept
add rule inet suri preraw meta l4proto { tcp, udp, icmp, ipv6-icmp } ${IFACE:+iifname \"$IFACE\" } queue flags bypass to ${QUEUE:-0}
add rule inet suri outraw meta l4proto { tcp, udp, icmp, ipv6-icmp } ${IFACE:+oifname \"$IFACE\" } queue flags bypass to ${QUEUE:-0}
NF
;; xt) iptables --wait -I INPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT; iptables --wait -I OUTPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT; iptables --wait -I INPUT 2 -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; iptables --wait -I OUTPUT 2 -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; iptables --wait -I FORWARD 2 -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; iptables --wait -I FORWARD 2 -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; ;; auto) if command -v nft >/dev/null 2>&1; then if nft list table inet suri >/dev/null 2>&1; then nft delete table inet suri; fi; nft -f - <<NF
create table inet suri
add chain inet suri preraw { type filter hook prerouting priority raw; policy accept; }
add chain inet suri outraw { type filter hook output     priority raw; policy accept; }
add rule inet suri preraw ct state established,related accept
add rule inet suri outraw ct state established,related accept
add rule inet suri preraw meta l4proto { tcp, udp, icmp, ipv6-icmp } ${IFACE:+iifname \"$IFACE\" } queue flags bypass to ${QUEUE:-0}
add rule inet suri outraw meta l4proto { tcp, udp, icmp, ipv6-icmp } ${IFACE:+oifname \"$IFACE\" } queue flags bypass to ${QUEUE:-0}
NF
else iptables --wait -I INPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT; iptables --wait -I OUTPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT; iptables --wait -I INPUT 2 -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; iptables --wait -I OUTPUT 2 -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; iptables --wait -I FORWARD 2 -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; iptables --wait -I FORWARD 2 -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}"; fi ;; esac'
ExecStart=/usr/bin/suricata -c ${SURICATA_CFG} -q ${QUEUE}
ExecStopPost=/usr/bin/env bash -c 'case "${BACKEND:-auto}" in nft) nft delete table inet suri 2>/dev/null || true ;; xt) iptables --wait -D INPUT -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; iptables --wait -D OUTPUT -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; iptables --wait -D FORWARD -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; iptables --wait -D FORWARD -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; ;; auto) if command -v nft >/dev/null 2>&1; then nft delete table inet suri 2>/dev/null || true; else iptables --wait -D INPUT -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; iptables --wait -D OUTPUT -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; iptables --wait -D FORWARD -i "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; iptables --wait -D FORWARD -o "${IFACE}" -j NFQUEUE --queue-num "${QUEUE}" 2>/dev/null || true; fi ;; esac'
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable --now suricata-inline.service
  ok "Boot service installed & started: suricata-inline.service (IPS-ALL)"
  logit "boot service installed (IPS-ALL) with hooks"
  ui_pause_redraw
}

remove_boot_ips_all() {
  systemctl disable --now suricata-inline.service 2>/dev/null || true
  rm -f /etc/systemd/system/suricata-inline.service "$ENV_FILE"
  systemctl daemon-reload
  ok "Boot service removed"; logit "boot service removed"; ui_pause_redraw
}

# -------- Interactive pickers --------
choose_iface() { ui_clear; msg "Detected default IFACE: ${IFACE_DEFAULT:-<none>}"; read -rp "Interface to use [${IFACE:-${IFACE_DEFAULT:-eth0}}]: " ans || true; IFACE="${ans:-${IFACE:-${IFACE_DEFAULT:-eth0}}}"; ok "IFACE set to $IFACE"; logit "IFACE=$IFACE"; ui_pause_redraw; }
choose_queue() { ui_clear; read -rp "NFQUEUE number [${QUEUE}]: " ans || true; if [[ -n "${ans:-}" && "$ans" =~ ^[0-9]+$ ]]; then QUEUE="$ans"; fi; ok "QUEUE set to $QUEUE"; logit "QUEUE=$QUEUE"; ui_pause_redraw; }
choose_backend() { ui_clear; msg "Current backend: ${BACKEND}"; read -rp "Choose backend [auto/xt/nft] (default: ${BACKEND}): " ans || true; ans="${ans:-$BACKEND}"; case "${ans,,}" in auto|xt|nft) BACKEND="${ans,,}"; ok "Backend set to: ${BACKEND}"; logit "backend=$BACKEND" ;; *) warn "Invalid choice. Keeping: ${BACKEND}" ;; esac; ui_pause_redraw; }

# -------- Menus --------
main_menu() {
  ui_clear
  local _base_tmp; _base_tmp="$( _yaml_default_rule_path)"; [[ -z "$_base_tmp" ]] && _base_tmp="/var/lib/suricata/rules"
  echo "==================== Meercata ===================="
  echo "Using config: ${SURICATA_CFG}"
  echo "Default rule path: ${_base_tmp}"
  echo "=================================================="
  echo " "
  echo "OPTION :"
  echo "1) IDS (sniff-only)"
  echo "2) IPS-ALL (inline enforce)"
  echo "3) Flush NFQUEUE rules"
  echo "4) Status"
  echo "5) Advanced…"
  echo "6) Rules Insight (rule-files)"
  echo "7) Edit rule-files / YAML tools"
  echo "8) Quit"
  echo "=================================================="
}

advanced_menu() {
  ui_clear
  echo "==================== Meercata ===================="
  echo " "
  echo "ADVANCE OPTION :"
  echo "1)  Choose interface (current: ${IFACE:-unset})"
  echo "2)  Choose NFQUEUE number (current: ${QUEUE})"
  echo "3)  Enable fail-open (nf_queue_bypass=1)"
  echo "4)  Disable fail-open (nf_queue_bypass=0)"
  echo "=================================================="
  echo "5)  EXPERIMENTAL : Install boot auto-start (IPS-ALL + pre-hooks)"
  echo "6)  EXPERIMENTAL : Remove boot auto-start"
  echo "=================================================="
  echo "7)  Backup iptables/ip6tables rules"
  echo "8)  Restore iptables/ip6tables rules"
  echo "9)  Insert allowlist rule (before NFQUEUE)"
  echo "10) Install nftables hooks (inet, TCP/UDP/ICMP/ICMPv6)"
  echo "11) Install nftables hooks (minimal: 7070 + ICMP/ICMPv6)"
  echo "12) Remove nftables hooks"
  echo "13) Show iptables counters"
  echo "14) Live monitor (suricatamon)"
  echo "15) Back"
  echo "16) Choose backend (current: ${BACKEND})"
  echo "17) Toggle runmode [workers/autofp] (current: $(awk '/^[ \t]*runmode:[ \t]*/{print $2; exit}' "$SURICATA_CFG" 2>/dev/null || echo autofp))"
  echo "18) NFQ settings… (batchcount / fail-open / write queue)"
  echo "=================================================="
}

usage() {
  cat <<EOF
meercata — Suricata IDS/IPS switcher
Usage: $0 [--ids | --ips | --flush | --status | --advanced | --help]
Env:  SURICATA_CFG  EDITOR  SURICATAMON_BIN  LOGFILE  BACKEND  QUEUE  IFACE
Note: FORWARD rules are symmetric (both iif/oif). If you need directional forward allowlists, edit allowlist_insert.
EOF
}

# -------- Entrypoint --------
need_root
require_bin suricata
require_deps

ui_clear
msg "Using config: ${SURICATA_CFG}"
_base_tmp="$( _yaml_default_rule_path)"; [[ -z "_base_tmp" ]] && _base_tmp="/var/lib/suricata/rules"
msg "Default rule path: ${_base_tmp}"; unset _base_tmp

case "${1:-interactive}" in
  --ids)     suricata_ids ;;
  --ips)     suricata_ips_all ;;
  --flush)   flush_nfq_xt; nft_flush; ui_pause_redraw; exit 0 ;;
  --status)  status_show; exit 0 ;;
  --advanced) ;;  # fallthrough to interactive
  --help|-h) usage; exit 0 ;;
  interactive|*) ;;
esac

while true; do
  main_menu
  read -rp "Select [1-8]: " opt
  case "$opt" in
    1) suricata_ids ;;
    2) suricata_ips_all ;;
    3) flush_nfq_xt; nft_flush; ui_pause_redraw ;;
    4) status_show ;;
    5)
      while true; do
        advanced_menu
        read -rp "Advanced [1-18]: " a
        case "$a" in
          1)  choose_iface ;;
          2)  choose_queue ;;
          3)  ensure_fail_open_on; ui_pause_redraw ;;
          4)  ensure_fail_open_off; ui_pause_redraw ;;
          5)  install_boot_ips_all ;;
          6)  remove_boot_ips_all ;;
          7)  backup_rules ;;
          8)  restore_rules ;;
          9)  allowlist_insert; ui_pause_redraw ;;
          10) nft_install_queue_all; ui_pause_redraw ;;
          11) nft_install_queue_minimal; ui_pause_redraw ;;
          12) nft_flush; ui_pause_redraw ;;
          13) show_counters ;;
          14) live_monitor ;;
          15) break ;;
          16) choose_backend ;;
          17) yaml_runmode_toggle; test_suricata || true; ui_pause_redraw ;;
          18)
            while true; do
              ui_clear
              echo "----- NFQ settings -----"
              echo "1) Set nfq.batchcount"
              echo "2) Set nfq.fail-open (yes/no)"
              echo "3) Write YAML nfq.queue = current QUEUE (${QUEUE})"
              echo "4) Back"
              read -rp "Select [1-4]: " nf || true
              case "$nf" in
                1) yaml_set_nfq_batchcount; test_suricata || true; ui_pause_redraw ;;
                2) yaml_set_nfq_failopen;  test_suricata || true; ui_pause_redraw ;;
                3) yaml_set_nfq_queue_to_env; test_suricata || true; ui_pause_redraw ;;
                4|"") break ;;
                *) err "Invalid option"; ui_pause_redraw ;;
              esac
            done
            ;;
          *)  err "Invalid option"; ui_pause_redraw ;;
        esac
      done
      ;;
    6) _rules_insight; ui_pause_redraw ;;
    7)
      while true; do
        ui_clear
        echo "----- Edit rule-files / YAML tools -----"
        echo "1) Enable/Disable via CHECKLIST"
        echo "2) Open rule-file(s) in editor ($EDITOR_BIN)"
        echo "3) YAML config summary (HOME_NET, EXTERNAL_NET, af-packet, pcap, nfq)"
        echo "4) Reload Suricata"
        echo "5) Back"
        read -rp "Select [1-5]: " opt2 || true
        case "$opt2" in
          1) _checklist_enable_disable; ui_pause_redraw ;;
          2) _open_rulefiles_vim; ui_pause_redraw ;;
          3) yaml_config_summary ;;
          4) systemctl reload suricata 2>/dev/null || systemctl restart suricata 2>/dev/null || true; ok "Suricata reloaded/restarted"; ui_pause_redraw ;;
          5|"") break ;;
          *) err "Invalid option"; ui_pause_redraw ;;
        esac
      done
      ;;
    8) exit 0 ;;
    *) err "Invalid option"; ui_pause_redraw ;;
  esac
done
