#!/usr/bin/env bash
# meercata: interactive IDS/IPS switcher for Suricata (NFQUEUE)
# - Clear screen on every action & always show banner
# - YAML summary shows ONLY active (uncommented) values from suricata.yaml

set -eEuo pipefail
IFS=$'\n\t'

# -------- Constants / Defaults (env-overridable) --------
SURICATA_CFG="${SURICATA_CFG:-/etc/suricata/suricata.yaml}"
EDITOR_BIN="${EDITOR:-vim}"
SURICATAMON_BIN="${SURICATAMON_BIN:-/usr/local/bin/suricatamon}"
LOGFILE="${LOGFILE:-/var/log/suricata-mode.log}"
BACKEND="${BACKEND:-auto}"           # auto|xt|nft
QUEUE="${QUEUE:-0}"
XTWAIT="--wait"

# Interface autodetect (best-effort)
IFACE_DEFAULT="$(ip route 2>/dev/null | awk '/default/ {print $5; exit}')"
IFACE="${IFACE:-${IFACE_DEFAULT:-}}"

# Capability probes
HAVE_IP6=1; command -v ip6tables >/dev/null 2>&1 || HAVE_IP6=0
IPT_V="$(iptables -V 2>/dev/null || true)"
NFT_BIN="$(command -v nft || true)"

# -------- UI helpers --------
C_RESET=$'\033[0m'; C_OK=$'\033[32m'; C_WARN=$'\033[33m'; C_ERR=$'\033[31m'; C_HEAD=$'\033[34m'; C_BANNER=$'\033[1;36m'
msg()  { printf "%s\n" "$*"; }
ok()   { printf "%b[OK]%b %s\n"   "$C_OK"   "$C_RESET" "$*"; }
warn() { printf "%b[WARN]%b %s\n" "$C_WARN" "$C_RESET" "$*"; }
err()  { printf "%b[ERR]%b %s\n"  "$C_ERR"  "$C_RESET" "$*" >&2; }
logit(){ printf "[%(%F %T)T] %s\n" -1 "$*" >>"$LOGFILE" 2>/dev/null || true; }

banner() {
  printf "%b" "$C_BANNER"
  cat <<'EOF'
  |  \/  |  ___   ___  _ __  ___  __ _ | |_  __ _ 
  | |\/| | / _ \ / _ \| '__|/ __|/ _` || __|/ _` |
  | |  | ||  __/|  __/| |  | (__| (_| || |_| (_| |
  |_|  |_| \___| \___||_|   \___|\__,_| \__|\__,_| 
EOF
  printf "%b" "$C_RESET"
}
ui_clear() { clear 2>/dev/null || printf "\033c"; banner; }
ui_pause() { read -rp $'\nPress Enter to continue…' _ || true; }
ui_pause_redraw() { ui_pause; ui_clear; }

need_root() { if [[ ${EUID:-$(id -u)} -ne 0 ]]; then err "Run as root."; exit 1; fi; }
require()  { command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 1; }; }

# Redraw banner on terminal resize
trap 'ui_clear' WINCH
trap 'err "Unexpected error on line $LINENO"' ERR

# -------- Backend helpers --------
backend_valid()    { case "$BACKEND" in auto|xt|nft) return 0;; *) return 1;; esac; }
describe_backend() { case "$BACKEND" in auto) echo "auto (prefer nft if present, else xtables)";; xt) echo "xtables (iptables/ip6tables)";; nft) echo "nftables (inet table hooks)";; esac; }
have_nft()         { [[ -n "$NFT_BIN" ]]; }

# -------- Suricata checks --------
test_suricata() {
  msg "[*] Testing Suricata config: $SURICATA_CFG"
  suricata -T -c "$SURICATA_CFG" >/dev/null
  ok "Suricata config OK"
}

ensure_fail_open_on()  {
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    sysctl -q net.netfilter.nf_queue_bypass=1 || true
    ok "Fail-open enabled (nf_queue_bypass=1)"
    logit "fail-open=1"
  else
    warn "Fail-open sysctl not available on this kernel."
  fi
}
ensure_fail_open_off() {
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    sysctl -q net.netfilter.nf_queue_bypass=0 || true
    ok "Fail-open disabled (nf_queue_bypass=0)"
    logit "fail-open=0"
  fi
}

# -------- iptables helpers --------
ipt_del_v4() { iptables $XTWAIT -D "$@" 2>/dev/null || true; }
ipt_del_v6() { [[ $HAVE_IP6 -eq 1 ]] && ip6tables $XTWAIT -D "$@" 2>/dev/null || true; }
ipt_ins_v4() { iptables $XTWAIT -I "$@"; }
ipt_ins_v6() { [[ $HAVE_IP6 -eq 1 ]] && ip6tables $XTWAIT -I "$@"; }

flush_nfq() {
  msg "[*] Flushing NFQUEUE hooks…"
  # v4
  ipt_del_v4 INPUT   -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v4 OUTPUT  -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v4 FORWARD -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v4 INPUT  -i lo -j ACCEPT
  ipt_del_v4 OUTPUT -o lo -j ACCEPT
  ipt_del_v4 INPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_del_v4 OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  # v6
  ipt_del_v6 INPUT   -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 OUTPUT  -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 FORWARD -j NFQUEUE --queue-num "$QUEUE"
  ipt_del_v6 INPUT  -i lo -j ACCEPT
  ipt_del_v6 OUTPUT -o lo -j ACCEPT
  ipt_del_v6 INPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_del_v6 OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ok "NFQUEUE hooks removed"
  logit "NFQUEUE flushed queue=$QUEUE"
}

# Conntrack fast-path (must be inserted BEFORE NFQUEUE)
add_ct_fastpath() {
  ipt_ins_v4 INPUT  1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_ins_v4 OUTPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_ins_v6 INPUT  1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  ipt_ins_v6 OUTPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
}

# Loopback accepts (must be before NFQUEUE)
insert_lo_accepts() {
  ipt_ins_v4 INPUT  1 -i lo -j ACCEPT
  ipt_ins_v4 OUTPUT 1 -o lo -j ACCEPT
  ipt_ins_v6 INPUT  1 -i lo -j ACCEPT
  ipt_ins_v6 OUTPUT 1 -o lo -j ACCEPT
}

# Queue all (position 2 so it's after fast-path/loopback)
queue_all_xt() {
  local if="${IFACE:-}"
  if [[ -n "$if" ]]; then
    ipt_ins_v4 INPUT   2 -i "$if" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 OUTPUT  2 -o "$if" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 FORWARD 2 -i "$if" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 INPUT   2 -i "$if" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 OUTPUT  2 -o "$if" -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 FORWARD 2 -i "$if" -j NFQUEUE --queue-num "$QUEUE"
  else
    ipt_ins_v4 INPUT   2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 OUTPUT  2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v4 FORWARD 2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 INPUT   2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 OUTPUT  2 -j NFQUEUE --queue-num "$QUEUE"
    ipt_ins_v6 FORWARD 2 -j NFQUEUE --queue-num "$QUEUE"
  fi
}

allowlist_insert() {
  read -rp "Direction (in/out/forward) [in]: " dir; dir="${dir:-in}"
  read -rp "Protocol (tcp/udp/all) [all]: " proto; proto="${proto:-all}"
  read -rp "Address (IP/CIDR) to allow (e.g., 1.2.3.4 or 10.0.0.0/24): " addr
  read -rp "Port (blank for any): " port || true

  local chain flagproto=() flagport=()
  case "$dir" in
    in) chain=INPUT ;;
    out) chain=OUTPUT ;;
    forward) chain=FORWARD ;;
    *) err "Invalid direction"; return ;;
  esac
  [[ "$proto" != all ]] && flagproto=( -p "$proto" )
  [[ -n "${port:-}" ]] && flagport=( --dport "$port" )

  iptables $XTWAIT -I "$chain" 1 "${flagproto[@]}" ${addr:+-s "$addr"} "${flagport[@]}" -j ACCEPT
  ok "IPv4 allowlisted at top of $chain"
  logit "allowlist v4 $chain proto=$proto addr=$addr port=${port:-any}"

  if [[ $HAVE_IP6 -eq 1 ]]; then
    ip6tables $XTWAIT -I "$chain" 1 "${flagproto[@]}" ${addr:+-s "$addr"} "${flagport[@]}" -j ACCEPT || true
    ok "IPv6 allowlisted at top of $chain"
    logit "allowlist v6 $chain proto=$proto addr=$addr port=${port:-any}"
  fi
}

# -------- nftables helpers --------
nft_flush() {
  if have_nft && $NFT_BIN list table inet suri >/dev/null 2>&1; then
    $NFT_BIN delete table inet suri || true
    ok "nftables: removed table inet suri"
  else
    warn "nftables: table inet suri not present"
  fi
}

nft_install_queue_all() {
  have_nft || { err "nft not found"; return 1; }
  local ifc="${IFACE:-}" match_in="" match_out=""
  [[ -n "$ifc" ]] && match_in="iifname \"$ifc\"" && match_out="oifname \"$ifc\""
  $NFT_BIN -f - <<EOF
table inet suri {
  chain preraw {
    type filter hook prerouting priority -300; policy accept;
    ct state established,related accept
    meta l4proto { tcp, udp, icmp, icmpv6 } ${match_in} queue num ${QUEUE} bypass
  }
  chain outraw {
    type filter hook output priority -300; policy accept;
    ct state established,related accept
    meta l4proto { tcp, udp, icmp, icmpv6 } ${match_out} queue num ${QUEUE} bypass
  }
}
EOF
  ok "nftables: inet/suri installed (queue ${QUEUE}; iface=${IFACE:-any})"
}

nft_install_queue_minimal() {
  have_nft || { err "nft not found"; return 1; }
  local ifc="${IFACE:-}" match_in="" match_out=""
  [[ -n "$ifc" ]] && match_in="iifname \"$ifc\"" && match_out="oifname \"$ifc\""
  $NFT_BIN -f - <<EOF
table inet suri {
  chain preraw {
    type filter hook prerouting priority -300; policy accept;
    ct state established,related accept
    tcp dport 7070 ${match_in} queue num ${QUEUE} bypass
    meta l4proto { icmp, icmpv6 } ${match_in} queue num ${QUEUE} bypass
  }
  chain outraw {
    type filter hook output priority -300; policy accept;
    ct state established,related accept
    tcp sport 7070 ${match_out} queue num ${QUEUE} bypass
    meta l4proto { icmp, icmpv6 } ${match_out} queue num ${QUEUE} bypass
  }
}
EOF
  ok "nftables: inet/suri minimal (TCP:7070 + ICMP/ICMPv6; iface=${IFACE:-any})"
}

nft_status() {
  if have_nft; then
    echo "===== nftables (inet suri) ====="
    $NFT_BIN list table inet suri 2>/dev/null || echo "(no inet suri table)"
  fi
}

# -------- Suricata process control --------
suricata_stop() { systemctl stop suricata 2>/dev/null || true; pkill -x suricata 2>/dev/null || true; }

suricata_ids() {
  [[ -n "${IFACE:-}" ]] || choose_iface
  ui_clear
  printf "%b=========================%b\n" "$C_HEAD" "$C_RESET"
  printf "%b SURICATA: IDS MODE %b\n" "$C_HEAD" "$C_RESET"
  printf "%b (sniff-only) %b\n" "$C_HEAD" "$C_RESET"
  printf "%b=========================%b\n" "$C_HEAD" "$C_RESET"
  suricata_stop; flush_nfq; nft_flush; test_suricata
  logit "MODE=IDS iface=$IFACE"
  exec suricata -c "$SURICATA_CFG" -i "$IFACE"
}

suricata_ips_all() {
  [[ -n "${IFACE:-}" ]] || choose_iface
  ui_clear
  printf "%b============================%b\n" "$C_ERR" "$C_RESET"
  printf "%b SURICATA: IPS-ALL MODE %b\n" "$C_ERR" "$C_RESET"
  printf "%b (inline enforce via NFQUEUE)%b\n" "$C_ERR" "$C_RESET"
  printf "%b============================%b\n" "$C_ERR" "$C_RESET"

  suricata_stop; flush_nfq; nft_flush; test_suricata; ensure_fail_open_on

  add_ct_fastpath
  insert_lo_accepts

  local used_backend=""
  case "$BACKEND" in
    nft)
      have_nft || { err "Requested nft backend but 'nft' not found."; return 1; }
      nft_install_queue_all; ok "Using nftables (forced)."; used_backend="nft"
      ;;
    xt)
      queue_all_xt; ok "Using xtables (forced)."; used_backend="xt"
      ;;
    auto|*)
      if have_nft; then
        nft_install_queue_all; ok "Using nftables (auto)."; used_backend="nft"
      else
        queue_all_xt; ok "Using xtables (auto fallback)."; used_backend="xt"
      fi
      ;;
  esac

  logit "MODE=IPS-ALL iface=$IFACE queue=$QUEUE backend=${used_backend:-unknown}"
  exec suricata -c "$SURICATA_CFG" -q "$QUEUE"
}

# -------- Rules: YAML parsing (mawk-safe) --------
_yaml_default_rule_path() {
  awk -F': *' '
    /^[ \t]*#/ {next}
    /^[ \t]*default-rule-path:[ \t]*/ { gsub(/["'\'']/, "", $2); print $2; exit }
  ' "$SURICATA_CFG"
}

_yaml_rulefiles() {
  awk '
    BEGIN { INBLK=0 }
    /^[ \t]*rule-files:[ \t]*$/ && $0 !~ /^[ \t]*#/ { INBLK=1; next }
    INBLK && /^[^ \t#][^:]*:/ { INBLK=0 }
    INBLK {
      line=$0
      if (line ~ /^[ \t]*#[ \t]*-[ \t]*/) {
        sub(/^[ \t]*#[ \t]*-[ \t]*/, "", line)
        sub(/[ \t]+#.*/, "", line)
        gsub(/["'\'']/, "", line)
        if (line != "") print "disabled\t" line
        next
      }
      if (line ~ /^[ \t]*-[ \t]*/) {
        sub(/^[ \t]*-[ \t]*/, "", line)
        sub(/[ \t]+#.*/, "", line)
        gsub(/["'\'']/, "", line)
        if (line != "") print "enabled\t" line
        next
      }
    }
  ' "$SURICATA_CFG"
}

_resolve_rule_path() {
  local base="$1" file="$2"
  if [[ "$file" = /* ]]; then printf "%s\n" "$file"; else printf "%s/%s\n" "${base%/}" "$file"; fi
}

# -------- Rules: enable/disable (idempotent) --------
_backup_yaml() {
  local ts dst
  ts="$(date +%Y%m%d-%H%M%S)"
  dst="${SURICATA_CFG}.${ts}.bak"
  cp -a -- "$SURICATA_CFG" "$dst"
  ok "Backup: $dst"
}

_set_rulefile_state() {
  local target="$1" desired="$2"
  [[ -n "$target" && -n "$desired" ]] || { err "Missing args"; return 1; }

  local tmp; tmp="$(mktemp)"
  awk -v target="$target" -v desired="$desired" '
    BEGIN { INBLK=0; changed=0 }
    /^[ \t]*rule-files:[ \t]*$/ && $0 !~ /^[ \t]*#/ { INBLK=1; print; next }
    INBLK && /^[^ \t#][^:]*:/ { INBLK=0 }
    INBLK {
      raw=$0; indent = match(raw,/[^ \t]/) - 1; if (indent < 0) indent=0; spaces = substr("                ",1,indent)
      line=raw; gsub(/["'\'']/, "", line); l=line
      sub(/^[ \t]*#?[ \t]*/, "", l); sub(/^[ \t]*-[ \t]*/, "", l); sub(/[ \t]+#.*/, "", l)
      if (l == target) {
        if (desired == "enabled") {
          sub(/^[ \t]*#[ \t]*/, "", raw)
          if (raw !~ /^[ \t]*-[ \t]*/) raw = spaces "- " target
          print raw
        } else {
          if (raw !~ /^[ \t]*#/) raw = spaces "# - " target
          else sub(/^[ \t]*#[ \t]*/, spaces "# - ")
          print raw
        }
        changed=1; next
      }
    }
    { print }
    END { if (!changed) exit 2 }
  ' "$SURICATA_CFG" > "$tmp" && mv "$tmp" "$SURICATA_CFG" || { rm -f "$tmp"; return 1; }
}

_rules_insight() {
  test_suricata 2>/dev/null || true
  local base; base="$(_yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"

  msg "----- rule-files ($SURICATA_CFG; default-path: $base) -----"

  local enabled=() disabled=() all=()
  local state file path size lines

  while IFS=$'\t' read -r state file; do
    [[ -z "${file:-}" ]] && continue
    all+=("$state|$file")
    if [[ "$state" == enabled ]]; then enabled+=("$file"); else disabled+=("$file"); fi
  done < <(_yaml_rulefiles | sort -u)

  if ((${#all[@]}==0)); then warn "No rule-files found in YAML."; return; fi

  msg ""
  msg "Enabled:"
  for file in "${enabled[@]}"; do
    path="$(_resolve_rule_path "$base" "$file")"
    if [[ -f "$path" ]]; then
      size="$(du -h "$path" | awk '{print $1}')"
      lines="$(wc -l <"$path" 2>/dev/null || echo 0)"
      printf " - %-24s -> %s (exists, %s, %s lines)\n" "$file" "$path" "$size" "$lines"
    else
      printf " - %-24s -> %s (missing)\n" "$file" "$path"
    fi
  done

  msg ""
  msg "Disabled:"
  if ((${#disabled[@]}==0)); then
    msg " (none)"
  else
    for file in "${disabled[@]}"; do
      path="$(_resolve_rule_path "$base" "$file")"
      if [[ -f "$path" ]]; then
        size="$(du -h "$path" | awk '{print $1}')"
        lines="$(wc -l <"$path" 2>/dev/null || echo 0)"
        printf " - %-24s -> %s (exists, %s, %s lines)\n" "$file" "$path" "$size" "$lines"
      else
        printf " - %-24s -> %s (missing)\n" "$file" "$path"
      fi
    done
  fi

  msg ""
  msg "Summary: ${#enabled[@]} enabled, ${#disabled[@]} disabled, total ${#all[@]}."
}

_has_dialog()   { command -v dialog >/dev/null 2>&1; }
_has_whiptail() { command -v whiptail >/dev/null 2>&1; }

_rulefiles_collect() {
  mapfile -t ITEMS  < <( _yaml_rulefiles | awk -F'\t' '{print $2}' | sed 's/^[ \t]*//; s/[ \t]*$//' | awk 'length>0' | sort -u )
  mapfile -t STATES < <( _yaml_rulefiles | awk -F'\t' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); if (length($2)>0) print $1 "\t" $2}' | sort -u )
}

_checklist_enable_disable() {
  _rulefiles_collect
  ((${#ITEMS[@]})) || { err "No rule-files in YAML."; return 1; }

  declare -A cur
  local s state f
  for s in "${STATES[@]}"; do
    state="${s%%$'\t'*}"; f="${s#*$'\t'}"
    [[ -z "$f" ]] && continue
    cur["$f"]="$state"
  done

  CHOSEN=()

  if _has_dialog; then
    local args=() out st desc
    for f in "${ITEMS[@]}"; do
      [[ -z "$f" ]] && continue
      st="${cur[$f]:-disabled}"; desc="Rule-file: $f"
      if ( [[ "$st" == enabled ]] ); then args+=("$f" "$desc" "on"); else args+=("$f" "$desc" "off"); fi
    done
    if out=$(dialog --stdout --no-tags --checklist "Select rule-files to ENABLE (unchecked will be DISABLED)" 20 80 14 "${args[@]}"); then
      read -r -a CHOSEN <<<"$out"
    else
      return 1
    fi
  elif _has_whiptail; then
    local args=() out st desc
    for f in "${ITEMS[@]}"; do
      [[ -z "$f" ]] && continue
      st="${cur[$f]:-disabled}"; desc="Rule-file: $f"
      if ( [[ "$st" == enabled ]] ); then args+=("$f" "$desc" "ON"); else args+=("$f" "$desc" "OFF"); fi
    done
    if out=$(whiptail --title "Suricata rule-files" --separate-output --checklist "Select rule-files to ENABLE (unchecked will be DISABLED)" 20 80 14 "${args[@]}" 3>&1 1>&2 2>&3); then
      mapfile -t CHOSEN <<<"$out"
    else
      return 1
    fi
  else
    msg "Available rule-files (current enabled marked [x]):"
    local i=1
    for f in "${ITEMS[@]}"; do
      printf " %2d) [%s] %s\n" "$i" "$([[ ${cur[$f]:-disabled} == enabled ]] && echo x || echo ' ')" "$f"
      ((i++))
    done
    read -rp "Enter indexes to ENABLE (others DISABLED), e.g. '1 3' or '1,3': " line || true
    [[ -z "${line:-}" ]] && return 1
    line="${line//,/ }"; local picks=( $line ) idx
    for idx in "${picks[@]}"; do
      [[ "$idx" =~ ^[0-9]+$ ]] || continue
      (( idx>=1 && idx<=${#ITEMS[@]} )) || continue
      f="${ITEMS[$((idx-1))]}"; [[ -z "$f" ]] && continue
      CHOSEN+=("$f")
    done
  fi

  declare -A WANT; for f in "${ITEMS[@]}"; do [[ -z "$f" ]] && continue; WANT["$f"]=disabled; done
  for f in "${CHOSEN[@]:-}"; do [[ -z "$f" ]] && continue; WANT["$f"]=enabled; done

  _backup_yaml
  local changed=0
  for f in "${ITEMS[@]}"; do
    [[ -z "$f" ]] && continue
    if [[ "${WANT[$f]}" != "${cur[$f]:-disabled}" ]]; then
      if _set_rulefile_state "$f" "${WANT[$f]}"; then
        printf "[OK] %s → %s\n" "$f" "${WANT[$f]}"; changed=1
      else
        printf "[ERR] %s → %s (failed)\n" "$f" "${WANT[$f]}"
      fi
    fi
  done
  (( changed )) && ok "Applied rule-file changes." || ok "No changes needed."
}

_open_rulefiles_vim() {
  mapfile -t ITEMS < <( _yaml_rulefiles | awk -F'\t' '{print $2}' | sed 's/^[ \t]*//; s/[ \t]*$//' | awk 'length>0' | sort -u )
  ((${#ITEMS[@]})) || { err "No rule-files in YAML."; return 1; }
  local base; base="$(_yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"

  msg "Available rule-files:"
  local i=1 f
  for f in "${ITEMS[@]}"; do printf " %2d) %s\n" "$i" "$f"; ((i++)); done

  read -rp "Pick index(es) to OPEN in ${EDITOR_BIN} (e.g., '1 3' or '1,3'): " line || true
  [[ -z "${line:-}" ]] && return 0
  line="${line//,/ }"

  local picks=( $line ) idx path paths=()
  for idx in "${picks[@]}"; do
    [[ "$idx" =~ ^[0-9]+$ ]] || continue
    (( idx>=1 && idx<=${#ITEMS[@]} )) || continue
    f="${ITEMS[$((idx-1))]}"; [[ -z "$f" ]] && continue
    path="$(_resolve_rule_path "$base" "$f")"
    if [[ ! -f "$path" ]]; then
      warn "Missing: $path — create?"
      read -rp "[y/N]: " yn || true
      if [[ "${yn,,}" == y ]]; then mkdir -p -- "$(dirname "$path")"; : > "$path"; fi
    fi
    paths+=("$path")
  done
  ((${#paths[@]})) && "$EDITOR_BIN" "${paths[@]}"
}

# -------- YAML Config Summary (ONLY active settings) --------
yaml_config_summary() {
  ui_clear
  echo "===== SURICATA YAML SUMMARY ====="
  echo "YAML file: $SURICATA_CFG"

  # default-rule-path
  local base; base="$(_yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"
  echo "default-rule-path: $base"

  # HOME_NET / EXTERNAL_NET (only active lines)
  awk '
    /^[ \t]*#/ { next }
    /^[ \t]*vars:[ \t]*$/ { invars=1; next }
    invars==1 && /^[ \t]*address-groups:[ \t]*$/ { inaddr=1; next }
    inaddr==1 && /^[ \t]*HOME_NET:[ \t]*/ { s=$0; sub(/^[ \t]*HOME_NET:[ \t]*/, "", s); gsub(/["'"'"']/, "", s); print "  HOME_NET: " s }
    inaddr==1 && /^[ \t]*EXTERNAL_NET:[ \t]*/ { s=$0; sub(/^[ \t]*EXTERNAL_NET:[ \t]*/, "", s); gsub(/["'"'"']/, "", s); print "  EXTERNAL_NET: " s }
    inaddr==1 && /^[ \t]*[^ #].*:/ && $0 !~ /HOME_NET:|EXTERNAL_NET:/ { if ($1!~/-/) inaddr=0 }
  ' "$SURICATA_CFG"

  # capture: af-packet (interfaces), pcap (interface), nfq keys — only active (uncommented)
  # af-packet
  awk '
    BEGIN{inblk=0; printed=0}
    /^[ \t]*#/ { next }
    /^[ \t]*af-packet:[ \t]*$/ { if (printed==0) { print "capture:"; printed=1 } ; print "  af-packet:"; inblk=1; next }
    inblk==1 && /^[^ \t#].*:/ { inblk=0 }
    inblk==1 && /^[ \t]*-[ \t]*interface:[ \t]*/ { s=$0; sub(/^[ \t]*-[ \t]*interface:[ \t]*/, "", s); gsub(/["'"'"']/, "", s); print "    - " s }
  ' "$SURICATA_CFG"

  # pcap
  awk '
    BEGIN{inblk=0; seen=0}
    /^[ \t]*#/ { next }
    /^[ \t]*pcap:[ \t]*$/ { print "  pcap:"; inblk=1; seen=1; next }
    inblk==1 && /^[^ \t#].*:/ { inblk=0 }
    inblk==1 && /^[ \t]*interface:[ \t]*/ { s=$0; sub(/^[ \t]*interface:[ \t]*/, "", s); gsub(/["'"'"']/, "", s); print "    - " s }
  ' "$SURICATA_CFG"

  # nfq block (only active keys that appear uncommented)
  awk '
    BEGIN{inblk=0; any=0}
    /^[ \t]*#/ { next }
    /^[ \t]*nfq:[ \t]*$/ { inblk=1; print "  nfq:"; next }
    inblk==1 && /^[^ \t#].*:/ { inblk=0 }
    inblk==1 {
      if ($0 ~ /^[ \t]*mode:[ \t]*/)      { s=$0; sub(/^[ \t]*mode:[ \t]*/, "", s); print "    mode: " s; any=1 }
      if ($0 ~ /^[ \t]*inline:[ \t]*/)    { s=$0; sub(/^[ \t]*inline:[ \t]*/, "", s); print "    inline: " s; any=1 }
      if ($0 ~ /^[ \t]*queue:[ \t]*/)     { s=$0; sub(/^[ \t]*queue:[ \t]*/, "", s); print "    queue: " s; any=1 }
      if ($0 ~ /^[ \t]*fail-open:[ \t]*/) { s=$0; sub(/^[ \t]*fail-open:[ \t]*/, "", s); print "    fail-open: " s; any=1 }
    }
  ' "$SURICATA_CFG"

  ui_pause_redraw
}

# -------- Status / Diagnostics --------
status_show() {
  ui_clear
  echo "===== SURICATA STATUS ====="
  if systemctl is-active --quiet suricata 2>/dev/null; then ok "systemd suricata: active"; else warn "systemd suricata: inactive"; fi
  pgrep -ax suricata || warn "No suricata process found"

  echo; echo "===== NFQUEUE (IPv4) ====="
  iptables -S | grep -n NFQUEUE || echo "(none)"

  if [[ $HAVE_IP6 -eq 1 ]]; then
    echo; echo "===== NFQUEUE (IPv6) ====="
    ip6tables -S | grep -n NFQUEUE || echo "(none)"
  fi

  echo; nft_status

  echo; echo "===== ENV ====="
  echo "IFACE=$IFACE QUEUE=$QUEUE CFG=$SURICATA_CFG"
  echo "iptables backend: $IPT_V"
  if [[ "$IPT_V" == *nf_tables* ]]; then warn "iptables-nft backend detected."; fi
  if backend_valid; then echo "backend preference: $(describe_backend)"; else echo "backend preference: (invalid: ${BACKEND})"; fi
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    echo "fail-open: $(sysctl -n net.netfilter.nf_queue_bypass 2>/dev/null)"
  else
    echo "fail-open: (not supported)"
  fi
  ui_pause_redraw
}

show_counters() {
  ui_clear
  iptables -vnL
  if [[ $HAVE_IP6 -eq 1 ]]; then echo; ip6tables -vnL; fi
  ui_pause_redraw
}

# -------- Live monitor --------
live_monitor() {
  ui_clear
  local log="${SURICATA_EVE:-/var/log/suricata/eve.json}"
  if [[ -x "$SURICATAMON_BIN" ]]; then
    ok "Launching suricatamon (Ctrl-C to exit)…"
    SURICATAMON_SHOW_SID="${SURICATAMON_SHOW_SID:-1}" \
    SURICATAMON_WIDE="${SURICATAMON_WIDE:-1}" \
    "$SURICATAMON_BIN" || warn "suricatamon exited with a non-zero status."
  else
    warn "suricatamon not found at: $SURICATAMON_BIN"
    warn "Install it and/or set SURICATAMON_BIN to its path."
    [[ -r "$log" ]] || { err "Cannot read $log"; ui_pause_redraw; return 1; }
    msg "[*] Fallback: tailing $log (first 200 lines)…"
    tail -n 200 "$log"
  fi
  ui_pause_redraw
}

# -------- Boot integration (systemd) --------
install_boot_ips_all() {
  local unit=/etc/systemd/system/suricata-inline.service
  cat > "$unit" <<EOF
[Unit]
Description=Suricata Inline (NFQUEUE)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
Environment=IFACE=\${IFACE}
Environment=QUEUE=\${QUEUE}
ExecStart=/usr/bin/suricata -c ${SURICATA_CFG} -q \${QUEUE}
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable --now suricata-inline.service
  ok "Boot service installed: suricata-inline.service (IPS-ALL)"
  logit "boot service installed (IPS-ALL)"
  ui_pause_redraw
}

remove_boot_ips_all() {
  systemctl disable --now suricata-inline.service 2>/dev/null || true
  rm -f /etc/systemd/system/suricata-inline.service
  systemctl daemon-reload
  ok "Boot service removed"
  logit "boot service removed"
  ui_pause_redraw
}

# -------- Interactive pickers --------
choose_iface() {
  ui_clear
  msg "Detected default IFACE: ${IFACE_DEFAULT:-<none>}"
  read -rp "Interface to use [${IFACE:-${IFACE_DEFAULT:-eth0}}]: " ans || true
  IFACE="${ans:-${IFACE:-${IFACE_DEFAULT:-eth0}}}"
  ok "IFACE set to $IFACE"
  logit "IFACE=$IFACE"
  ui_pause_redraw
}

choose_queue() {
  ui_clear
  read -rp "NFQUEUE number [${QUEUE}]: " ans || true
  if [[ -n "${ans:-}" && "$ans" =~ ^[0-9]+$ ]]; then QUEUE="$ans"; fi
  ok "QUEUE set to $QUEUE"
  logit "QUEUE=$QUEUE"
  ui_pause_redraw
}

choose_backend() {
  ui_clear
  msg "Current backend: $(describe_backend)"
  read -rp "Choose backend [auto/xt/nft] (default: ${BACKEND}): " ans || true
  ans="${ans:-$BACKEND}"
  case "${ans,,}" in
    auto|xt|nft) BACKEND="${ans,,}"; ok "Backend set to: $(describe_backend)"; logit "backend=$BACKEND" ;;
    *) warn "Invalid choice. Keeping: $(describe_backend)" ;;
  esac
  ui_pause_redraw
}

# -------- Menus --------
main_menu() {
  ui_clear
  local _base_tmp; _base_tmp="$(_yaml_default_rule_path)"; [[ -z "$_base_tmp" ]] && _base_tmp="/var/lib/suricata/rules"
  echo "==================== Meercata ===================="
  echo "Using config: ${SURICATA_CFG}"
  echo "Default rule path: ${_base_tmp}"
  echo "=================================================="
  echo " "
  echo "OPTION :"
  echo "1) IDS (sniff-only)"
  echo "2) IPS-ALL (inline enforce)"
  echo "3) Flush NFQUEUE rules"
  echo "4) Status"
  echo "5) Advanced…"
  echo "6) Rules Insight (rule-files)"
  echo "7) Edit rule-files / YAML tools"
  echo "8) Quit"
  echo "=================================================="
}

advanced_menu() {
  ui_clear
  echo "==================== Meercata ===================="
  echo " "
  echo "ADVANCE OPTION :"
  echo "1)  Choose interface (current: ${IFACE:-unset})"
  echo "2)  Choose NFQUEUE number (current: ${QUEUE})"
  echo "3)  Enable fail-open (nf_queue_bypass=1)"
  echo "4)  Disable fail-open (nf_queue_bypass=0)"
  echo "5)  Install boot auto-start (IPS-ALL)"
  echo "6)  Remove boot auto-start"
  echo "7)  Backup iptables/ip6tables rules"
  echo "8)  Restore iptables/ip6tables rules"
  echo "9)  Insert allowlist rule (before NFQUEUE)"
  echo "10) Install nftables hooks (inet, TCP/UDP/ICMP/ICMPv6)"
  echo "11) Install nftables hooks (minimal: 7070 + ICMP/ICMPv6)"
  echo "12) Remove nftables hooks"
  echo "13) Show iptables counters"
  echo "14) Live monitor (suricatamon)"
  echo "15) Back"
  echo "16) Choose backend (current: $(describe_backend))"
  echo "=================================================="
}

usage() {
  cat <<EOF
meercata — Suricata IDS/IPS switcher
Usage: $0 [--ids | --ips | --flush | --status | --advanced | --help]
Env:  SURICATA_CFG  EDITOR  SURICATAMON_BIN  LOGFILE  BACKEND  QUEUE  IFACE
EOF
}

# -------- Entrypoint --------
need_root
require suricata
require iptables

ui_clear
msg "Using config: ${SURICATA_CFG}"
_base_tmp="$(_yaml_default_rule_path)"; [[ -z "$_base_tmp" ]] && _base_tmp="/var/lib/suricata/rules"
msg "Default rule path: ${_base_tmp}"
unset _base_tmp

case "${1:-interactive}" in
  --ids)     suricata_ids ;;
  --ips)     suricata_ips_all ;;
  --flush)   flush_nfq; ui_pause_redraw; exit 0 ;;
  --status)  status_show; exit 0 ;;
  --advanced) ;;  # fallthrough to interactive
  --help|-h) usage; exit 0 ;;
  interactive|*) ;;
esac

while true; do
  main_menu
  read -rp "Select [1-8]: " opt
  case "$opt" in
    1) suricata_ids ;;
    2) suricata_ips_all ;;
    3) flush_nfq; ui_pause_redraw ;;
    4) status_show ;;
    5)
      while true; do
        advanced_menu
        read -rp "Advanced [1-16]: " a
        case "$a" in
          1)  choose_iface ;;
          2)  choose_queue ;;
          3)  ensure_fail_open_on; ui_pause_redraw ;;
          4)  ensure_fail_open_off; ui_pause_redraw ;;
          5)  install_boot_ips_all ;;
          6)  remove_boot_ips_all ;;
          7)  backup_rules ;;
          8)  restore_rules ;;
          9)  allowlist_insert; ui_pause_redraw ;;
          10) nft_install_queue_all; ui_pause_redraw ;;
          11) nft_install_queue_minimal; ui_pause_redraw ;;
          12) nft_flush; ui_pause_redraw ;;
          13) show_counters ;;
          14) live_monitor ;;
          15) break ;;
          16) choose_backend ;;
          *)  err "Invalid option"; ui_pause_redraw ;;
        esac
      done
      ;;
    6) _rules_insight; ui_pause_redraw ;;
    7)
      while true; do
        ui_clear
        echo "----- Edit rule-files / YAML tools -----"
        echo "1) Enable/Disable via CHECKLIST"
        echo "2) Open rule-file(s) in editor ($EDITOR_BIN)"
        echo "3) YAML config summary (HOME_NET, EXTERNAL_NET, af-packet, pcap, nfq)"
        echo "4) Reload Suricata"
        echo "5) Back"
        read -rp "Select [1-5]: " opt2 || true
        case "$opt2" in
          1) _checklist_enable_disable; ui_pause_redraw ;;
          2) _open_rulefiles_vim; ui_pause_redraw ;;
          3) yaml_config_summary ;;
          4) systemctl reload suricata 2>/dev/null || systemctl restart suricata 2>/dev/null || true; ok "Suricata reloaded/restarted"; ui_pause_redraw ;;
          5|"") break ;;
          *) err "Invalid option"; ui_pause_redraw ;;
        esac
      done
      ;;
    8) exit 0 ;;
    *) err "Invalid option"; ui_pause_redraw ;;
  esac
done
