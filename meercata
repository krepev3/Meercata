#!/usr/bin/env bash
# suricata-mode: interactive IDS/IPS switcher for Suricata (NFQUEUE)
# Core: IDS (sniff-only), IPS-ALL (enforce), Flush, Status
# Advanced: iface/queue, fail-open, boot auto-start, allowlist, backup/restore, counters, live monitor
# Rules:
#   - Rules Insight
#   - Edit rule-files: CHECKLIST (dialog/whiptail/plain) + multi-open in vim
# Notes:
#   - mawk/busybox-safe regexes ([ \t] instead of [:space:])
#   - awk state var INBLK (avoid 'in')
#   - default editor is vim (override by exporting EDITOR)

set -euo pipefail

# -------- Defaults (env-overridable) --------
SURICATA_CFG="${SURICATA_CFG:-/etc/suricata/suricata.yaml}"
IFACE_DEFAULT="$(ip route | awk '/default/ {print $5; exit}')"
IFACE="${IFACE:-${IFACE_DEFAULT:-}}"
QUEUE="${QUEUE:-0}"
XTWAIT="--wait"
LOGFILE="${LOGFILE:-/var/log/suricata-mode.log}"
EDITOR_BIN="${EDITOR:-vim}"                                  # default editor
SURICATAMON_BIN="${SURICATAMON_BIN:-/usr/local/bin/suricatamon}"  # external monitor

# -------- Detect IPv6 & iptables backend --------
HAVE_IP6=1; command -v ip6tables >/dev/null 2>&1 || HAVE_IP6=0
IPT_V="$(iptables -V 2>/dev/null || true)"
NFT_BACKEND=0; [[ "$IPT_V" == *"nf_tables"* ]] && NFT_BACKEND=1
NFT_BIN="$(command -v nft || true)"

# -------- UI helpers --------
say()  { printf "%b\n" "$*"; }
ok()   { printf "\033[32m[OK]\033[0m %b\n" "$*"; }
warn() { printf "\033[33m[WARN]\033[0m %b\n" "$*"; }
err()  { printf "\033[31m[ERR]\033[0m %b\n" "$*" >&2; }
logit(){ printf "[%(%F %T)T] %s\n" -1 "$*" >>"$LOGFILE" 2>/dev/null || true; }

banner_meercata() {
  printf "\033[1;36m"
  cat <<'EOF'
|  \/  |  ___   ___  _ __  ___  __ _ | |_  __ _ 
| |\/| | / _ \ / _ \| '__|/ __|/ _` || __|/ _` |
| |  | ||  __/|  __/| |  | (__| (_| || |_| (_| |
|_|  |_| \___| \___||_|   \___|\__,_| \__|\__,_|
                                                
EOF
  printf "\033[0m"
}

need_root() { if [[ ${EUID:-$(id -u)} -ne 0 ]]; then err "Run as root."; exit 1; fi; }

choose_iface() {
  say "Detected default IFACE: ${IFACE_DEFAULT:-<none>}"
  read -rp "Interface to use [${IFACE:-${IFACE_DEFAULT:-eth0}}]: " ans || true
  IFACE="${ans:-${IFACE:-${IFACE_DEFAULT:-eth0}}}"
  ok "IFACE set to $IFACE"; logit "IFACE=$IFACE"
}

choose_queue() {
  read -rp "NFQUEUE number [${QUEUE}]: " ans || true
  [[ -n "${ans:-}" && "$ans" =~ ^[0-9]+$ ]] && QUEUE="$ans"
  ok "QUEUE set to $QUEUE"; logit "QUEUE=$QUEUE"
}

# -------- Suricata checks --------
test_suricata() {
  say "[*] Testing Suricata configuration: $SURICATA_CFG"
  suricata -T -c "$SURICATA_CFG" >/dev/null
  ok "Suricata config OK"
}

ensure_fail_open_on() {
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    sysctl -q net.netfilter.nf_queue_bypass=1 || true
    ok "Fail-open enabled (nf_queue_bypass=1)"; logit "fail-open=1"
  else
    warn "Fail-open sysctl not available on this kernel."
  fi
}
ensure_fail_open_off() {
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    sysctl -q net.netfilter.nf_queue_bypass=0 || true
    ok "Fail-open disabled (nf_queue_bypass=0)"; logit "fail-open=0"
  fi
}

# -------- iptables helpers --------
flush_nfq_v4() {
  iptables  $XTWAIT -D INPUT   -j NFQUEUE --queue-num "$QUEUE" 2>/dev/null || true
  iptables  $XTWAIT -D OUTPUT  -j NFQUEUE --queue-num "$QUEUE" 2>/dev/null || true
  iptables  $XTWAIT -D FORWARD -j NFQUEUE --queue-num "$QUEUE" 2>/dev/null || true
  iptables  $XTWAIT -D INPUT  -i lo -j ACCEPT 2>/dev/null || true
  iptables  $XTWAIT -D OUTPUT -o lo -j ACCEPT 2>/dev/null || true
}
flush_nfq_v6() {
  [[ $HAVE_IP6 -eq 1 ]] || return 0
  ip6tables $XTWAIT -D INPUT   -j NFQUEUE --queue-num "$QUEUE" 2>/dev/null || true
  ip6tables $XTWAIT -D OUTPUT  -j NFQUEUE --queue-num "$QUEUE" 2>/dev/null || true
  ip6tables $XTWAIT -D FORWARD -j NFQUEUE --queue-num "$QUEUE" 2>/dev/null || true
  ip6tables $XTWAIT -D INPUT  -i lo -j ACCEPT 2>/dev/null || true
  ip6tables $XTWAIT -D OUTPUT -o lo -j ACCEPT 2>/dev/null || true
}
flush_nfq() { say "[*] Flushing NFQUEUE hooksâ€¦"; flush_nfq_v4; flush_nfq_v6; ok "NFQUEUE hooks removed"; logit "NFQUEUE flushed for queue=$QUEUE"; }

insert_lo_accepts_v4() { iptables  $XTWAIT -I INPUT 1 -i lo -j ACCEPT; iptables  $XTWAIT -I OUTPUT 1 -o lo -j ACCEPT; }
insert_lo_accepts_v6() { [[ $HAVE_IP6 -eq 1 ]] && { ip6tables $XTWAIT -I INPUT 1 -i lo -j ACCEPT; ip6tables $XTWAIT -I OUTPUT 1 -o lo -j ACCEPT; } || true; }

queue_all_v4() { iptables  $XTWAIT -I INPUT -j NFQUEUE --queue-num "$QUEUE"; iptables  $XTWAIT -I OUTPUT -j NFQUEUE --queue-num "$QUEUE"; iptables  $XTWAIT -I FORWARD -j NFQUEUE --queue-num "$QUEUE"; }
queue_all_v6() { [[ $HAVE_IP6 -eq 1 ]] && { ip6tables $XTWAIT -I INPUT -j NFQUEUE --queue-num "$QUEUE"; ip6tables $XTWAIT -I OUTPUT -j NFQUEUE --queue-num "$QUEUE"; ip6tables $XTWAIT -I FORWARD -j NFQUEUE --queue-num "$QUEUE"; } || true; }

allowlist_insert() {
  read -rp "Direction (in/out/forward) [in]: " dir; dir="${dir:-in}"
  read -rp "Protocol (tcp/udp/all) [all]: " proto; proto="${proto:-all}"
  read -rp "Address (IP/CIDR) to allow (e.g., 1.2.3.4 or 10.0.0.0/24): " addr
  read -rp "Port (blank for any): " port || true
  local chain flagproto="" flagport=""
  case "$dir" in in) chain="INPUT";; out) chain="OUTPUT";; forward) chain="FORWARD";; *) err "Invalid direction"; return;; esac
  [[ "$proto" != "all" ]] && flagproto="-p $proto"
  [[ -n "$port" ]] && flagport="--dport $port"
  iptables $XTWAIT -I "$chain" 1 $flagproto ${addr:+-s "$addr"} $flagport -j ACCEPT
  ok "IPv4 allowlisted at top of $chain"; logit "allowlist v4 $chain proto=$proto addr=$addr port=${port:-any}"
  if [[ $HAVE_IP6 -eq 1 ]]; then
    ip6tables $XTWAIT -I "$chain" 1 $flagproto ${addr:+-s "$addr"} $flagport -j ACCEPT || true
    ok "IPv6 allowlisted at top of $chain"; logit "allowlist v6 $chain proto=$proto addr=$addr port=${port:-any}"
  fi
}

# -------- nftables (inet) helpers --------
have_nft() { [[ -n "$NFT_BIN" ]]; }
nft_flush() {
  if have_nft && $NFT_BIN list table inet suri >/dev/null 2>&1; then
    $NFT_BIN delete table inet suri || true
    ok "nftables: removed table inet suri"
  else
    warn "nftables: table inet suri not present"
  fi
}
nft_install_queue_all() {
  have_nft || { err "nft not found"; return 1; }
  $NFT_BIN -f - <<EOF
table inet suri {
  chain preraw {
    type filter hook prerouting priority -300; policy accept;
    meta l4proto { tcp, udp } queue num ${QUEUE} bypass
  }
  chain outraw {
    type filter hook output priority -300; policy accept;
    meta l4proto { tcp, udp } queue num ${QUEUE} bypass
  }
}
EOF
  ok "nftables: inet/suri installed (queue ${QUEUE} on prerouting/output for TCP/UDP)"
}
nft_status() {
  if have_nft; then
    echo "===== nftables (inet suri) ====="
    $NFT_BIN list table inet suri 2>/dev/null || echo "(no inet suri table)"
  fi
}

# -------- Suricata process control --------
suricata_stop() { systemctl stop suricata 2>/dev/null || true; pkill -x suricata 2>/dev/null || true; }

suricata_ids() {
  [[ -n "$IFACE" ]] || choose_iface
  echo -e "\033[34m=========================\033[0m"
  echo -e "\033[34m     SURICATA: IDS MODE  \033[0m"
  echo -e "\033[34m (sniff-only, no enforce) \033[0m"
  echo -e "\033[34m=========================\033[0m"
  suricata_stop; flush_nfq; nft_flush; test_suricata
  logit "MODE=IDS iface=$IFACE"
  exec suricata -c "$SURICATA_CFG" -i "$IFACE"
}

suricata_ips_all() {
  [[ -n "$IFACE" ]] || choose_iface
  echo -e "\033[31m============================\033[0m"
  echo -e "\033[31m   SURICATA: IPS-ALL MODE   \033[0m"
  echo -e "\033[31m (inline enforce via NFQUEUE)\033[0m"
  echo -e "\033[31m============================\033[0m"
  suricata_stop; flush_nfq; nft_flush; test_suricata; ensure_fail_open_on

  if have_nft; then
    nft_install_queue_all
    ok "Using nftables inet hooks (covers IPv4+IPv6)."
  else
    insert_lo_accepts_v4; insert_lo_accepts_v6
    queue_all_v4; queue_all_v6
    ok "Using legacy iptables/ip6tables hooks (INPUT/OUTPUT/FORWARD)."
  fi

  logit "MODE=IPS-ALL iface=$IFACE queue=$QUEUE backend=$([[ -n "$NFT_BIN" ]] && echo nft || echo xt))"
  exec suricata -c "$SURICATA_CFG" -q "$QUEUE"
}

# -------- Rules: parsers (mawk-safe) --------
_yaml_default_rule_path() {
  awk -F': *' '
    /^[ \t]*#/ {next}
    /^[ \t]*default-rule-path:[ \t]*/ { gsub(/["'\''"]/, "", $2); print $2; exit }
  ' "$SURICATA_CFG"
}
# emits: "enabled\tfile" or "disabled\tfile"
_yaml_rulefiles() {
  awk '
    BEGIN { INBLK=0 }
    /^[ \t]*rule-files:[ \t]*$/ && $0 !~ /^[ \t]*#/ { INBLK=1; next }
    INBLK && /^[^ \t#][^:]*:/ { INBLK=0 }
    INBLK {
      line=$0
      if (line ~ /^[ \t]*#[ \t]*-[ \t]*/) {
        sub(/^[ \t]*#[ \t]*-[ \t]*/, "", line)
        sub(/[ \t]+#.*/, "", line)
        gsub(/["'\''"]/, "", line)
        if (line != "") print "disabled\t" line
        next
      }
      if (line ~ /^[ \t]*-[ \t]*/) {
        sub(/^[ \t]*-[ \t]*/, "", line)
        sub(/[ \t]+#.*/, "", line)
        gsub(/["'\''"]/, "", line)
        if (line != "") print "enabled\t" line
        next
      }
    }
  ' "$SURICATA_CFG"
}

_resolve_rule_path() { local base="$1" file="$2"; if [[ "$file" = /* ]]; then printf "%s\n" "$file"; else printf "%s/%s\n" "${base%/}" "$file"; fi; }

# -------- Rules: enforce state (idempotent enable/disable) --------
_backup_yaml() { local ts dst; ts="$(date +%Y%m%d-%H%M%S)"; dst="${SURICATA_CFG}.${ts}.bak"; cp -a -- "$SURICATA_CFG" "$dst"; ok "Backup: $dst"; }

_set_rulefile_state() {
  local target="$1" desired="$2"
  [[ -n "$target" && -n "$desired" ]] || { err "Missing args to _set_rulefile_state"; return 1; }
  local tmp; tmp="$(mktemp)"
  awk -v target="$target" -v desired="$desired" '
    BEGIN { INBLK=0; changed=0 }
    /^[ \t]*rule-files:[ \t]*$/ && $0 !~ /^[ \t]*#/ { INBLK=1; print; next }
    INBLK && /^[^ \t#][^:]*:/ { INBLK=0 }
    INBLK {
      raw=$0
      indent = match(raw,/[^ \t]/) - 1; if (indent < 0) indent=0
      spaces = substr("                                                                ",1,indent)
      line=raw
      gsub(/["'\''"]/, "", line)
      l=line
      sub(/^[ \t]*#?[ \t]*-[ \t]*/, "", l)
      sub(/[ \t]+#.*/, "", l)
      if (l == target) {
        if (desired == "enabled") {
          sub(/^[ \t]*#[ \t]*/, "", raw)
          if (raw !~ /^[ \t]*-[ \t]*/) raw = spaces "- " target
          print raw
        } else {
          if (raw !~ /^[ \t]*#/) raw = spaces "# - " target
          else { sub(/^[ \t]*#[ \t]*/ , spaces "# - "); raw = raw }
          print raw
        }
        changed=1; next
      }
    }
    { print }
    END { if (!changed) exit 2 }
  ' "$SURICATA_CFG" > "$tmp" && mv "$tmp" "$SURICATA_CFG" || { rm -f "$tmp"; return 1; }
  return 0
}

# -------- Rules: insight --------
_rules_insight() {
  test_suricata 2>/dev/null || true
  local base path state file size lines
  base="$(_yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"
  say "----- rule-files (${SURICATA_CFG}; default-path: $base) -----"

  local enabled=() disabled=() all=()
  while IFS=$'\t' read -r state file; do
    [[ -z "${file:-}" ]] && continue
    all+=("$state|$file")
    [[ "$state" == "enabled" ]] && enabled+=("$file") || disabled+=("$file")
  done < <(_yaml_rulefiles | sort -u)

  if ((${#all[@]}==0)); then warn "No rule-files found in YAML."; return; fi

  say; say "Enabled:"
  local f
  for f in "${enabled[@]}"; do
    path="$(_resolve_rule_path "$base" "$f")"
    if [[ -f "$path" ]]; then
      size="$(du -h "$path" | awk '{print $1}')"; lines="$(wc -l <"$path" 2>/dev/null || echo 0)"
      printf "  - %-24s -> %s  (exists, %s, %s lines)\n" "$f" "$path" "$size" "$lines"
    else
      printf "  - %-24s -> %s  (missing)\n" "$f" "$path"
    fi
  done

  say; say "Disabled:"
  if ((${#disabled[@]}==0)); then
    say "  (none)"
  else
    for f in "${disabled[@]}"; do
      path="$(_resolve_rule_path "$base" "$f")"
      if [[ -f "$path" ]]; then
        size="$(du -h "$path" | awk '{print $1}')"; lines="$(wc -l <"$path" 2>/dev/null || echo 0)"
        printf "  - %-24s -> %s  (exists, %s, %s lines)\n" "$f" "$path" "$size" "$lines"
      else
        printf "  - %-24s -> %s  (missing)\n" "$f" "$path"
      fi
    done
  fi
  say; say "Summary: ${#enabled[@]} enabled, ${#disabled[@]} disabled, total ${#all[@]}."
}

# -------- Checklist UI (dialog / whiptail / fallback) --------
_has_dialog()   { command -v dialog >/dev/null 2>&1; }
_has_whiptail() { command -v whiptail >/dev/null 2>&1; }

_rulefiles_collect() {
  mapfile -t ITEMS < <(
    _yaml_rulefiles | awk -F'\t' '{print $2}' | sed 's/^[ \t]*//; s/[ \t]*$//' | awk 'length>0' | sort -u
  )
  mapfile -t STATES < <(
    _yaml_rulefiles | awk -F'\t' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); if (length($2)>0) print $1 "\t" $2}' | sort -u
  )
}

_checklist_enable_disable() {
  _rulefiles_collect
  if ((${#ITEMS[@]}==0)); then err "No rule-files in YAML."; return 1; fi

  declare -A cur
  local s f state
  for s in "${STATES[@]}"; do
    state="${s%%$'\t'*}"
    f="${s#*$'\t'}"
    [[ -z "$f" ]] && continue
    cur["$f"]="$state"
  done

  CHOSEN=()
  if _has_dialog; then
    local args=() out st desc
    for f in "${ITEMS[@]}"; do
      [[ -z "$f" ]] && continue
      st="${cur[$f]:-disabled}"
      desc="Rule-file: $f"
      if [[ "$st" == "enabled" ]]; then args+=("$f" "$desc" "on"); else args+=("$f" "$desc" "off"); fi
    done
    if out=$(dialog --stdout --no-tags --checklist "Select rule-files to ENABLE (unchecked will be DISABLED)" 20 80 14 "${args[@]}"); then
      read -r -a CHOSEN <<<"$out"
    else
      return 1
    fi
  elif _has_whiptail; then
    local args=() out st desc
    for f in "${ITEMS[@]}"; do
      [[ -z "$f" ]] && continue
      st="${cur[$f]:-disabled}"
      desc="Rule-file: $f"
      if [[ "$st" == "enabled" ]]; then args+=("$f" "$desc" "ON"); else args+=("$f" "$desc" "OFF"); fi
    done
    if out=$(whiptail --title "Suricata rule-files" --separate-output --checklist "Select rule-files to ENABLE (unchecked will be DISABLED)" 20 80 14 "${args[@]}" 3>&1 1>&2 2>&3); then
      mapfile -t CHOSEN <<<"$out"
    else
      return 1
    fi
  else
    say "Available rule-files (current enabled marked [x]):"
    local i=1 st
    for f in "${ITEMS[@]}"; do
      [[ -z "$f" ]] && continue
      st="${cur[$f]:-disabled}"
      printf "  %2d) [%s] %s\n" "$i" "$([[ $st == enabled ]] && echo x || echo ' ')" "$f"
      ((i++))
    done
    read -rp "Enter indexes to ENABLE (others will be DISABLED), e.g. '1 3' or '1,3': " line || true
    [[ -z "${line:-}" ]] && return 1
    line="${line//,/ }"
    local picks=( $line ) idx
    for idx in "${picks[@]}"; do
      [[ "$idx" =~ ^[0-9]+$ ]] || continue
      (( idx>=1 && idx<=${#ITEMS[@]} )) || continue
      f="${ITEMS[$((idx-1))]}"; [[ -z "$f" ]] && continue
      CHOSEN+=("$f")
    done
  fi

  declare -A WANT
  for f in "${ITEMS[@]}"; do [[ -z "$f" ]] && continue; WANT["$f"]="disabled"; done
  for f in "${CHOSEN[@]:-}"; do [[ -z "$f" ]] && continue; WANT["$f"]="enabled"; done

  _backup_yaml
  local changed=0
  for f in "${ITEMS[@]}"; do
    [[ -z "$f" ]] && continue
    if [[ "${WANT[$f]}" != "${cur[$f]:-disabled}" ]]; then
      if _set_rulefile_state "$f" "${WANT[$f]}"; then
        printf "[OK] %s â†’ %s\n" "$f" "${WANT[$f]}"; changed=1
      else
        printf "[ERR] %s â†’ %s (failed)\n" "$f" "${WANT[$f]}"
      fi
    fi
  done
  (( changed )) && ok "Applied rule-file changes." || ok "No changes needed."
  return 0
}

# -------- Rules: open files (multi) --------
_open_rulefiles_vim() {
  mapfile -t ITEMS < <(
    _yaml_rulefiles | awk -F'\t' '{print $2}' | sed 's/^[ \t]*//; s/[ \t]*$//' | awk 'length>0' | sort -u
  )
  if ((${#ITEMS[@]}==0)); then err "No rule-files in YAML."; return 1; fi
  local base; base="$(_yaml_default_rule_path)"; [[ -n "$base" ]] || base="/var/lib/suricata/rules"

  say "Available rule-files:"
  local i=1 f; for f in "${ITEMS[@]}"; do printf "  %2d) %s\n" "$i" "$f"; ((i++)); done
  read -rp "Pick index(es) to OPEN in ${EDITOR_BIN} (e.g., '1 3' or '1,3'): " line || true
  [[ -z "${line:-}" ]] && return 0
  line="${line//,/ }"
  local picks=( $line ) idx path
  local paths=()
  for idx in "${picks[@]}"; do
    [[ "$idx" =~ ^[0-9]+$ ]] || continue
    (( idx>=1 && idx<=${#ITEMS[@]} )) || continue
    f="${ITEMS[$((idx-1))]}"; [[ -z "$f" ]] && continue
    path="$(_resolve_rule_path "$base" "$f")"
    if [[ ! -f "$path" ]]; then
      warn "Missing: $path â€” create?"; read -rp "[y/N]: " yn || true
      if [[ "${yn,,}" == "y" ]]; then mkdir -p -- "$(dirname "$path")"; : > "$path"; fi
    fi
    paths+=("$path")
  done
  ((${#paths[@]})) && "$EDITOR_BIN" "${paths[@]}"
}

# -------- Menus: rules --------
rules_insight_menu() { _rules_insight; say; read -rp "Press Enter to continueâ€¦" _ || true; }

edit_rulefiles_menu() {
  while true; do
    say; say "----- Edit rule-files -----"
    say "1) Enable/Disable via CHECKLIST"
    say "2) Open rule-file(s) in editor ($EDITOR_BIN)"
    say "3) Reload Suricata"
    say "4) Back"
    read -rp "Select [1-4]: " opt || true
    case "$opt" in
      1) _checklist_enable_disable ;;
      2) _open_rulefiles_vim ;;
      3) systemctl reload suricata 2>/dev/null || systemctl restart suricata 2>/dev/null || true; ok "Suricata reloaded/restarted" ;;
      4|"") break ;;
      *) err "Invalid option" ;;
    esac
  done
}

# -------- Status / Diagnostics --------
status_show() {
  echo "===== SURICATA STATUS ====="
  systemctl is-active --quiet suricata && ok "systemd suricata: active" || warn "systemd suricata: inactive"
  pgrep -ax suricata || warn "No suricata process found"
  echo
  echo "===== NFQUEUE (IPv4) ====="; iptables -S | grep -n NFQUEUE || echo "(none)"
  if [[ $HAVE_IP6 -eq 1 ]]; then echo; echo "===== NFQUEUE (IPv6) ====="; ip6tables -S | grep -n NFQUEUE || echo "(none)"; fi
  echo
  nft_status
  echo
  echo "===== ENV ====="
  echo "IFACE=$IFACE  QUEUE=$QUEUE  CFG=$SURICATA_CFG"
  echo "iptables backend: $IPT_V"; [[ $NFT_BACKEND -eq 1 ]] && warn "iptables-nft backend detected."
  if sysctl -a 2>/dev/null | grep -q '^net.netfilter.nf_queue_bypass'; then
    echo "fail-open: $(sysctl -n net.netfilter.nf_queue_bypass 2>/dev/null)"
  else
    echo "fail-open: (not supported)"
  fi
}

show_counters() { iptables -vnL; [[ $HAVE_IP6 -eq 1 ]] && { echo; ip6tables -vnL; } || true; }

# -------- Live monitor (external suricatamon) --------
live_monitor() {
  local log="${SURICATA_EVE:-/var/log/suricata/eve.json}"

  if [[ -x "$SURICATAMON_BIN" ]]; then
    ok "Launching suricatamon (Ctrl-C to exit)â€¦"
    SURICATAMON_SHOW_SID="${SURICATAMON_SHOW_SID:-1}" \
    SURICATAMON_WIDE="${SURICATAMON_WIDE:-1}" \
      "$SURICATAMON_BIN" || warn "suricatamon exited with a non-zero status."
  else
    warn "suricatamon not found at: $SURICATAMON_BIN"
    warn "Install it and/or set SURICATAMON_BIN to its path."
    [[ -r "$log" ]] || { err "Cannot read $log"; return 1; }
    say "[*] Fallback: tailing $log (first 200 lines)â€¦"
    tail -n 200 "$log"
  fi
}

# -------- Boot integration (IPS-ALL service) --------
install_boot_ips_all() {
  local unit=/etc/systemd/system/suricata-inline.service
  cat > "$unit" <<EOF
[Unit]
Description=Suricata Inline (NFQUEUE)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
Environment=IFACE=\${IFACE}
Environment=QUEUE=\${QUEUE}
ExecStart=/usr/bin/suricata -c ${SURICATA_CFG} -q \${QUEUE}
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable --now suricata-inline.service
  ok "Boot service installed: suricata-inline.service (IPS-ALL)"; logit "boot service installed (IPS-ALL)"
}

remove_boot_ips_all() {
  systemctl disable --now suricata-inline.service 2>/dev/null || true
  rm -f /etc/systemd/system/suricata-inline.service
  systemctl daemon-reload
  ok "Boot service removed"; logit "boot service removed"
}

# -------- Backup/Restore rules --------
backup_rules() {
  mkdir -p /root/iptables-bak
  iptables-save  > /root/iptables-bak/iptables.v4
  [[ $HAVE_IP6 -eq 1 ]] && ip6tables-save > /root/iptables-bak/iptables.v6 || true
  ok "Saved to /root/iptables-bak/"; logit "iptables rules backed up"
}
restore_rules() {
  [[ -f /root/iptables-bak/iptables.v4 ]] && iptables-restore  < /root/iptables-bak/iptables.v4
  [[ -f /root/iptables-bak/iptables.v6 && $HAVE_IP6 -eq 1 ]] && ip6tables-restore < /root/iptables-bak/iptables.v6 || true
  ok "Restored from /root/iptables-bak/"; logit "iptables rules restored"
}

# -------- Menus --------
main_menu() {
  echo
  banner_meercata
  echo "============= Meercata ============="
  echo "1) IDS (sniff-only)"
  echo "2) IPS-ALL (inline enforce)"
  echo "3) Flush NFQUEUE rules"
  echo "4) Status"
  echo "5) Advancedâ€¦"
  echo "6) Rules Insight (rule-files)"
  echo "7) Edit rule-files (YAML; checklist/open)"
  echo "8) Quit"
  echo "===================================="
}
advanced_menu() {
  echo
  echo "----------- Advanced ------------"
  echo "1) Choose interface (current: ${IFACE:-unset})"
  echo "2) Choose NFQUEUE number (current: ${QUEUE})"
  echo "3) Enable fail-open (nf_queue_bypass=1)"
  echo "4) Disable fail-open (nf_queue_bypass=0)"
  echo "5) Install boot auto-start (IPS-ALL)"
  echo "6) Remove boot auto-start"
  echo "7) Backup iptables/ip6tables rules"
  echo "8) Restore iptables/ip6tables rules"
  echo "9) Insert allowlist rule (before NFQUEUE)"
  echo "10) Install nftables hooks (inet, v4+v6)"
  echo "11) Remove nftables hooks"
  echo "12) Show iptables counters"
  echo "13) Live monitor (suricatamon)"
  echo "14) Back"
  echo "---------------------------------"
}

# -------- Main --------
need_root
clear
banner_meercata
say "Using config: ${SURICATA_CFG}"
_base_tmp="$(_yaml_default_rule_path)"; [[ -z "$_base_tmp" ]] && _base_tmp="/var/lib/suricata/rules"
say "Default rule path: ${_base_tmp}"; unset _base_tmp

while true; do
  main_menu
  read -rp "Select [1-8]: " opt
  case "$opt" in
    1) suricata_ids ;;
    2) suricata_ips_all ;;
    3) flush_nfq ;;
    4) status_show ;;
    5)
      while true; do
        advanced_menu
        read -rp "Advanced [1-14]: " a
        case "$a" in
          1) choose_iface ;;
          2) choose_queue ;;
          3) ensure_fail_open_on ;;
          4) ensure_fail_open_off ;;
          5) install_boot_ips_all ;;
          6) remove_boot_ips_all ;;
          7) backup_rules ;;
          8) restore_rules ;;
          9) allowlist_insert ;;
          10) nft_install_queue_all ;;
          11) nft_flush ;;
          12) show_counters ;;
          13) live_monitor ;;
          14) break ;;
          *) err "Invalid option" ;;
        esac
      done
      ;;
    6) rules_insight_menu ;;
    7) edit_rulefiles_menu ;;
    8) exit 0 ;;
    *) err "Invalid option" ;;
  esac
done
